using System;
using System.Collections.Generic;
using System.Drawing;

namespace rpg_deneme.UI.Controls.GameEntities;

public class SkillProjectile
{
    public float X;
    public float Y;
    public float DX;
    public float DY;
    public int Damage;
    public int Size = 10;
    public bool IsEnemy;
    public bool IsCrit;
    public bool IsAoE = false; // Alan hasarı mı?
    public int AoERadius = 50; // Alan hasarı yarıçapı
    public Rectangle Bounds => new Rectangle((int)X - Size / 2, (int)Y - Size / 2, Size, Size);

    public int VisualType = 0; // 0=Basic, 1=Fire, 2=Ice, 3=Arcane/Dark, 4=Lightning, 5=Poison
    public Color CustomColor = Color.Empty;

    // Animation properties
    public int AnimTick = 0;
    
    // Use circular buffer for trail instead of List with RemoveAt(0)
    private readonly PointF[] _trailBuffer = new PointF[MaxTrailLength];
    private int _trailStart = 0;
    private int _trailCount = 0;
    private const int MaxTrailLength = 8;

    // Read-only accessor for trail points (oldest to newest)
    public IReadOnlyList<PointF> Trail => new TrailAccessor(this);

    private readonly struct TrailAccessor : IReadOnlyList<PointF>
    {
        private readonly SkillProjectile _proj;
        public TrailAccessor(SkillProjectile proj) => _proj = proj;
   public int Count => _proj._trailCount;
     public PointF this[int index]
        {
  get
 {
          if (index < 0 || index >= _proj._trailCount) throw new IndexOutOfRangeException();
      return _proj._trailBuffer[(_proj._trailStart + index) % MaxTrailLength];
      }
        }
        public IEnumerator<PointF> GetEnumerator()
        {
            for (int i = 0; i < _proj._trailCount; i++)
  yield return _proj._trailBuffer[(_proj._trailStart + i) % MaxTrailLength];
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public SkillProjectile(float x, float y, float tx, float ty, int dmg, bool enemy, bool isCrit = false, int visualType = 0)
    {
        X = x;
        Y = y;
Damage = dmg;
        IsEnemy = enemy;
        IsCrit = isCrit;
        VisualType = visualType;

        // Set size based on visual type
        Size = visualType switch
      {
            1 => 14, // Fire - larger
      2 => 10, // Ice
      3 => 12, // Arcane
    _ => enemy ? 8 : 10
        };

        // Set speed based on visual type
        float spd = enemy ? 5f : 9f;
  if (visualType == 1) spd = 11f; // Fireball moderate speed
        if (visualType == 2) spd = 13f; // Ice bolt faster
        if (visualType == 3) spd = 10f; // Arcane moderate

  float dist = (float)Math.Sqrt(Math.Pow(tx - x, 2.0) + Math.Pow(ty - y, 2.0));
        if (dist < 1f) dist = 1f;
     DX = (tx - x) / dist * spd;
   DY = (ty - y) / dist * spd;
    }

    public void Move()
    {
    // Add current position to trail using circular buffer (O(1) instead of O(n))
        if (_trailCount < MaxTrailLength)
      {
_trailBuffer[_trailCount] = new PointF(X, Y);
            _trailCount++;
  }
        else
        {
          _trailBuffer[_trailStart] = new PointF(X, Y);
     _trailStart = (_trailStart + 1) % MaxTrailLength;
        }

        X += DX;
        Y += DY;
        AnimTick++;
    }
}
