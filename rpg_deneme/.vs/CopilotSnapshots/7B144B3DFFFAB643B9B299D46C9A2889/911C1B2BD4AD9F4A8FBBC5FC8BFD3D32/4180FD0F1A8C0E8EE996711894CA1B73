using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using rpg_deneme.Business;
using rpg_deneme.Core;
using rpg_deneme.Models;
using rpg_deneme.UI.Controls.GameEntities;
using SkiaSharp;
using SkiaSharp.Views.Desktop;
using SkillProjectile = rpg_deneme.UI.Controls.GameEntities.SkillProjectile;

namespace rpg_deneme.UI.Controls;

public partial class UcArena
{
 // Skia caches (similar to GDI+ brush/pen caches)
 private readonly Dictionary<uint, SKPaint> _skFillPaintCache = new();
 private readonly Dictionary<(uint Color, float Width), SKPaint> _skStrokePaintCache = new();

 // Background cache (Skia)
 private SKBitmap? _skBackgroundCache;
 private bool _skBackgroundNeedsRedraw = true;
 private int _skCachedWidth;
 private int _skCachedHeight;
 private bool _skLastTownMode;

 // Cache System.Drawing.Image -> SKBitmap conversion (hotbar icons)
 private readonly Dictionary<int, SKBitmap> _hotbarSkBitmapCache = new();

 private SKBitmap? GetHotbarBitmap(System.Drawing.Image? img)
 {
 if (img is not System.Drawing.Bitmap bmp) return null;
 int key = bmp.GetHashCode();
 if (_hotbarSkBitmapCache.TryGetValue(key, out var cached)) return cached;

 // Convert once and keep; disposal handled in Dispose()
 var skBmp = bmp.ToSKBitmap();
 _hotbarSkBitmapCache[key] = skBmp;
 return skBmp;
 }

 // Reused paints (avoid allocating every frame)
 private readonly SKPaint _enemyNameTextPaint = new() { Color = SKColors.White, TextSize =10, IsAntialias = false, TextAlign = SKTextAlign.Center };
 private readonly SKPaint _hotbarCountPaint = new() { Color = SKColors.White, TextSize =18, IsAntialias = false, FakeBoldText = true };
 private readonly SKPaint _hotbarIndexPaint = new() { Color = SKColors.Gray, TextSize =18, IsAntialias = false };
 private readonly SKPaint _hotbarManaPaint = new() { Color = SKColors.Cyan, TextSize =14, IsAntialias = false };
 private readonly SKPaint _hotbarCooldownTextPaint = new() { Color = SKColors.White, TextSize =20, IsAntialias = false, FakeBoldText = true, TextAlign = SKTextAlign.Center };
 private readonly SKPaint _cooldownFillPaint = new() { Color = new SKColor(0,0,0,180), IsAntialias = false, Style = SKPaintStyle.Fill };
 private readonly SKPaint _resultsButtonTextPaint = new() { Color = SKColors.White, TextSize =20, IsAntialias = false, FakeBoldText = true, TextAlign = SKTextAlign.Center };
 
 // Reusable paints for effects (avoid allocating every frame)
 private readonly SKPaint _effectTextPaint = new() { IsAntialias = false, FakeBoldText = true };
 private readonly SKPaint _effectTextOutlinePaint = new() { IsAntialias = false, FakeBoldText = true };
 private readonly SKPaint _notificationPaint = new() { TextSize = 20, IsAntialias = false, FakeBoldText = true };
 private readonly SKPaint _npcOutlinePaint = new() { Color = SKColors.Black, TextSize = 12, IsAntialias = false, FakeBoldText = true, TextAlign = SKTextAlign.Center };
 private readonly SKPaint _npcTextPaint = new() { Color = SKColors.White, TextSize = 12, IsAntialias = false, FakeBoldText = true, TextAlign = SKTextAlign.Center };

 // Reusable SKPath objects to avoid allocation every frame
 private readonly SKPath _characterPath = new();
 private readonly SKPath _helmetPath = new();

 private SKBitmap? _enemySkCachedBitmap;
 private SKBitmap? _playerSkCachedBitmap;
 private SKBitmap? _npcSkCachedBitmap;
 private SKBitmap? _projectileSkCachedBitmap;
 private SKBitmap? _effectSkCachedBitmap;

 // Entity bitmaps (Skia)
 private SKBitmap _skPlayerBitmap = null!;
 private SKBitmap _skEnemyBitmap = null!;
 private SKBitmap _skNpcBitmap = null!;
 private SKBitmap _skProjectileBitmap = null!;
 private SKBitmap _skEffectBitmap = null!;

 private SKPaint GetFill(uint argb)
 {
 if (!_skFillPaintCache.TryGetValue(argb, out var p))
 {
 p = new SKPaint
 {
 IsAntialias = false,
 Style = SKPaintStyle.Fill,
 Color = new SKColor(argb)
 };
 _skFillPaintCache[argb] = p;
 }
 return p;
 }

 private static uint Key(SKColor c) => ((uint)c.Alpha <<24) | ((uint)c.Red <<16) | ((uint)c.Green <<8) | c.Blue;

 private SKPaint GetFill(SKColor color) => GetFill(Key(color));

 private SKPaint GetStroke(SKColor color, float width =1f)
 {
 var key = (Key(color), width);
 if (!_skStrokePaintCache.TryGetValue(key, out var p))
 {
 p = new SKPaint
 {
 IsAntialias = false,
 Style = SKPaintStyle.Stroke,
 StrokeWidth = width,
 Color = color
 };
 _skStrokePaintCache[key] = p;
 }
 return p;
 }

 private static SKColor ToSK(Color c) => new SKColor(c.R, c.G, c.B, c.A);

 private void Arena_SKPaintSurface(object? sender, SKPaintGLSurfaceEventArgs e)
 {
 var canvas = e.Surface.Canvas;
 canvas.Clear(SKColors.Black);

 int w = e.BackendRenderTarget.Width;
 int h = e.BackendRenderTarget.Height;
 if (w <=0 || h <=0) return;

 Fps_OnFrameRendered();

 // screen shake
 int shakeOffsetX =0;
 int shakeOffsetY =0;
 if (_shakeDuration >0)
 {
 shakeOffsetX = _rnd.Next(-_shakeMagnitude, _shakeMagnitude +1);
 shakeOffsetY = _rnd.Next(-_shakeMagnitude, _shakeMagnitude +1);
 _shakeDuration--;
 }

 canvas.Save();
 canvas.Translate(shakeOffsetX, shakeOffsetY);

 DrawBackgroundSkia(canvas, w, h);

 if (_isTownMode)
 {
 for (int i =0; i < _npcs.Count; i++)
 DrawProceduralNPCSkia(canvas, _npcs[i]);
 }

 if (_player != null)
 {
 DrawProceduralCharacterSkia(canvas, _player, SKColors.Blue, _hero.Class, _currentWeaponUpgradeLevel, _currentWeaponGrade);
 float barY = _player.Y -30f;
 DrawModernBarSkia(canvas, _player.X, barY, _player.Width,5f, _player.CurrentHP, _player.MaxHP, SKColors.Crimson, SKColors.DarkGray);
 }

 for (int i =0; i < _enemies.Count; i++)
 DrawEnemySkia(canvas, _enemies[i]);

 for (int i =0; i < _projectiles.Count; i++)
 DrawProjectileSkia(canvas, _projectiles[i]);

 DrawEffectsSkia(canvas);
 DrawHotbarSkia(canvas);

 if (_showResults)
 DrawResultsOverlaySkia(canvas, w, h);

 DrawBuffsSkia(canvas);
 DrawNotificationsSkia(canvas);

 // Debug overlay
 Fps_Draw(canvas);

 canvas.Restore();
 }

 private void DrawProjectileSkia(SKCanvas canvas, SkillProjectile proj)
 {
 int trailCount = proj.TrailCount;
 if (trailCount > 1)
 {
 var baseColor = ToSK(GetProjectileColor(proj.VisualType, proj.IsEnemy));
 for (int t = 0; t < trailCount - 1; t++)
 {
 float trailAlpha = (float)(t + 1) / trailCount * 0.6f;
 float trailSize = proj.Size * (0.3f + (float)t / trailCount * 0.5f);
 var trailColor = baseColor.WithAlpha((byte)(trailAlpha * 255));
 var pt = proj.GetTrailPoint(t);
 canvas.DrawOval(pt.X, pt.Y, trailSize / 2, trailSize / 2, GetFill(trailColor));
 }
 }

 float ps = proj.Size;
 float pulse = (float)Math.Sin(proj.AnimTick *0.3) *0.15f +1f;
 float cx = proj.X;
 float cy = proj.Y;

 if (proj.IsEnemy)
 {
 canvas.DrawOval(cx, cy, (ps +6) /2, (ps +6) /2, GetFill(new SKColor(139,0,0,80)));
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(SKColors.Crimson));
 canvas.DrawOval(cx, cy, (ps *0.5f) /2, (ps *0.5f) /2, GetFill(SKColors.DarkRed));
 return;
 }

 switch (proj.VisualType)
 {
 case 1: // fire
 canvas.DrawOval(cx, cy, ((ps +10) * pulse) /2, ((ps +10) * pulse) /2, GetFill(new SKColor(255,165,0,60)));
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(SKColors.OrangeRed));
 canvas.DrawOval(cx, cy, (ps *0.6f) /2, (ps *0.6f) /2, GetFill(SKColors.Yellow));
 canvas.DrawOval(cx, cy, (ps *0.3f) /2, (ps *0.3f) /2, GetFill(SKColors.White));
 {
 float flameOffset = (float)Math.Sin(proj.AnimTick *0.5) *3;
 canvas.DrawOval(cx - ps /2 -2 + flameOffset +2, cy - ps /2 -4 +3,2,3, GetFill(SKColors.Orange));
 canvas.DrawOval(cx + ps /2 -2 - flameOffset +1.5f, cy - ps /2 -3 +2.5f,1.5f,2.5f, GetFill(SKColors.OrangeRed));
 }
 break;

 case 2: // ice
 canvas.DrawOval(cx, cy, (ps +8) /2, (ps +8) /2, GetFill(new SKColor(0,255,255,50)));
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(new SKColor(224,255,255)));
 {
 using var crystalPen = GetStroke(new SKColor(240,248,255),1.5f);
 for (int i =0; i <6; i++)
 {
 float angle = (float)(i * Math.PI /3 + proj.AnimTick *0.05);
 float r = ps *0.4f;
 canvas.DrawLine(cx, cy, cx + (float)Math.Cos(angle) * r, cy + (float)Math.Sin(angle) * r, crystalPen);
 }
 }
 if (proj.AnimTick %4 <2)
 canvas.DrawOval(cx, cy - ps *0.3f,2,2, GetFill(SKColors.White));
 break;

 case 3: // arcane
 canvas.DrawOval(cx, cy, (ps +12) /2, (ps +12) /2, GetFill(new SKColor(147,112,219,40)));
 {
 float ringAngle = proj.AnimTick *0.1f;
 canvas.DrawOval(cx + (float)Math.Sin(ringAngle) *2, cy, (ps +4) /2, (ps +4) /2, GetStroke(new SKColor(221,160,221,150),1.5f));
 }
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(SKColors.DarkViolet));
 canvas.DrawOval(cx, cy, (ps *0.6f) /2, (ps *0.6f) /2, GetFill(new SKColor(147,112,219)));
 canvas.DrawOval(cx + ps *0.05f, cy - ps *0.05f, (ps *0.25f) /2, (ps *0.25f) /2, GetFill(new SKColor(221,160,221)));
 break;

 case 4: // lightning
 {
 float flicker = (float)Math.Sin(proj.AnimTick *0.8) *0.5f +1f;
 canvas.DrawOval(cx, cy, ((ps +8) * flicker) /2, ((ps +8) * flicker) /2, GetFill(new SKColor(255,255,0,70)));
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(new SKColor(255,215,0)));
 canvas.DrawOval(cx, cy, (ps *0.5f) /2, (ps *0.5f) /2, GetFill(SKColors.White));
 var sparkPen = GetStroke(SKColors.Yellow,1.5f);
 for (int sp =0; sp <4; sp++)
 {
 float angle = (float)(sp * Math.PI /2 + proj.AnimTick *0.2);
 float len = ps *0.6f * flicker;
 canvas.DrawLine(cx, cy, cx + (float)Math.Cos(angle) * len, cy + (float)Math.Sin(angle) * len, sparkPen);
 }
 }
 break;

 case 5: // toxic
 canvas.DrawOval(cx, cy, (ps +8) /2, (ps +8) /2, GetFill(new SKColor(50,205,50,50)));
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(SKColors.DarkGreen));
 canvas.DrawOval(cx, cy, (ps *0.6f) /2, (ps *0.6f) /2, GetFill(SKColors.LimeGreen));
 {
 float bubbleOffset = (float)Math.Sin(proj.AnimTick *0.3) *2;
 canvas.DrawOval(cx - ps *0.2f + bubbleOffset, cy - ps *0.5f -3,2,2, GetFill(new SKColor(154,205,50)));
 }
 break;

 default:
 canvas.DrawOval(cx, cy, ps /2, ps /2, GetFill(SKColors.Cyan));
 break;
 }
 }

 private void DrawEnemySkia(SKCanvas canvas, BattleEntity en)
 {
 if (en.CurrentHP <=0) return;
 if (float.IsNaN(en.X) || float.IsInfinity(en.X)) en.X =0f;
 if (float.IsNaN(en.Y) || float.IsInfinity(en.Y)) en.Y =0f;

 int pads =50;
 if (en.X < -pads || en.X > _skgl.Width + pads || en.Y < -pads || en.Y > _skgl.Height + pads) return;

 var bodyColor = en.IsRanged ? SKColors.Purple : SKColors.Crimson;
 DrawProceduralCharacterSkia(canvas, en, bodyColor,0);
 DrawModernBarSkia(canvas, en.X, en.Y -12f, en.Width,6f, en.CurrentHP, en.MaxHP, SKColors.OrangeRed, SKColors.DarkRed);
 }

 private void DrawModernBarSkia(SKCanvas canvas, float x, float y, float w, float h, int val, int max, SKColor front, SKColor back)
 {
 float pct = Math.Max(0, Math.Min(1, (float)val / (float)max));
 var rect = new SKRect(x, y, x + w, y + h);
 canvas.DrawRect(rect, GetFill(back));
 if (pct >0)
 {
 var f = new SKRect(x, y, x + w * pct, y + h);
 canvas.DrawRect(f, GetFill(front));
 }
 canvas.DrawRect(rect, GetStroke(SKColors.Black,1));
 }

 private void DrawBackgroundSkia(SKCanvas canvas, int w, int h)
 {
 bool needsRedraw = _skBackgroundCache == null ||
 _skCachedWidth != w ||
 _skCachedHeight != h ||
 _skLastTownMode != _isTownMode ||
 _skBackgroundNeedsRedraw;

 if (needsRedraw)
 {
 _skBackgroundCache?.Dispose();
 _skBackgroundCache = new SKBitmap(w, h, true);
 _skCachedWidth = w;
 _skCachedHeight = h;
 _skLastTownMode = _isTownMode;
 _skBackgroundNeedsRedraw = false;

 using var bgCanvas = new SKCanvas(_skBackgroundCache);
 if (_isTownMode)
 DrawTownBackgroundSkia(bgCanvas, w, h);
 else
 DrawArenaBackgroundSkia(bgCanvas, w, h);
 }

 canvas.DrawBitmap(_skBackgroundCache!,0,0);
 }

 private void DrawTownBackgroundSkia(SKCanvas canvas, int w, int h)
 {
 canvas.Clear(new SKColor(143,188,143)); // DarkSeaGreen

 // roads
 canvas.DrawRect(new SKRect(w /2 -100,0, w /2 +100, h), GetFill(SKColors.Gray));
 canvas.DrawRect(new SKRect(0, h /2 -80, w, h /2 +80), GetFill(SKColors.Gray));

 var p = GetStroke(new SKColor(0,0,0,50),2);
 for (int y =0; y < h; y +=40)
 {
 canvas.DrawLine(w /2 -100, y, w /2 +100, y, p);
 canvas.DrawLine(w /2 -50, y, w /2 -50, y +40, p);
 canvas.DrawLine(w /2 +50, y, w /2 +50, y +40, p);
 }
 for (int x =0; x < w; x +=40)
 {
 canvas.DrawLine(x, h /2 -80, x, h /2 +80, p);
 canvas.DrawLine(x, h /2, x +40, h /2, p);
 }

 DrawSimpleTreeSkia(canvas,50,50);
 DrawSimpleTreeSkia(canvas,150,80);
 DrawSimpleTreeSkia(canvas, w -80,60);
 DrawSimpleTreeSkia(canvas, w -180,100);

 float cx = w /2f;
 float cy = h /2f;
 canvas.DrawOval(cx, cy,60,60, GetFill(new SKColor(135,206,250))); // LightSkyBlue
 canvas.DrawOval(cx, cy,60,60, GetStroke(SKColors.Gray,2));
 canvas.DrawOval(cx, cy,40,40, GetFill(new SKColor(0,191,255))); // DeepSkyBlue
 canvas.DrawOval(cx, cy,20,20, GetStroke(SKColors.White,2));
 }

 private void DrawArenaBackgroundSkia(SKCanvas canvas, int w, int h)
 {
 canvas.Clear(new SKColor(46,34,25));

 var bgRnd = new Random(12345);
 for (int i =0; i <15; i++)
 {
 int rx = bgRnd.Next(0, w);
 int ry = bgRnd.Next(0, h);
 int rw = bgRnd.Next(30,80);
 int rh = bgRnd.Next(20,60);
 canvas.DrawOval(rx + rw /2f, ry + rh /2f, rw /2f, rh /2f, GetFill(new SKColor(0,0,0,30)));
 }
 for (int i =0; i <30; i++)
 {
 int rx = bgRnd.Next(0, w);
 int ry = bgRnd.Next(0, h);
 canvas.DrawRect(new SKRect(rx, ry, rx +4, ry +4), GetFill(SKColors.Gray));
 }

 canvas.DrawRect(new SKRect(0,0, w,20), GetFill(new SKColor(139,69,19))); // SaddleBrown
 canvas.DrawRect(new SKRect(0, h -20, w, h), GetFill(new SKColor(139,69,19)));
 canvas.DrawRect(new SKRect(0,0,20, h), GetFill(new SKColor(139,69,19)));
 canvas.DrawRect(new SKRect(w -20,0, w, h), GetFill(new SKColor(139,69,19)));

 var border = GetStroke(new SKColor(40,20,10),1);
 canvas.DrawRect(new SKRect(0,0, w -1, h -1), border);
 canvas.DrawRect(new SKRect(19,19, w -20, h -20), border);
 }

 private void DrawSimpleTreeSkia(SKCanvas canvas, float x, float y)
 {
 canvas.DrawOval(x +10, y +50,30,10, GetFill(new SKColor(0,0,0,60)));
 canvas.DrawRect(new SKRect(x, y, x +20, y +50), GetFill(new SKColor(160,82,45))); // Sienna
 canvas.DrawOval(x +10, y -5,35,35, GetFill(new SKColor(34,139,34))); // ForestGreen
 canvas.DrawOval(x +15, y +0,25,25, GetFill(new SKColor(0,100,0))); // DarkGreen
 }

 private void DrawProceduralNPCSkia(SKCanvas canvas, NpcEntity npc)
 {
 float x = npc.X;
 float y = npc.Y;
 float w = npc.Width;
 float h = npc.Height;

 canvas.DrawOval(x + w /2f, y + h -3, (w +10) /2f,5, GetFill(new SKColor(0,0,0,60)));

 switch (npc.Type)
 {
 case Enums.NpcType.Merchant:
 canvas.DrawRect(new SKRect(x -10, y + h /2, x + w +10, y + h), GetFill(new SKColor(160,82,45)));
 canvas.DrawRect(new SKRect(x -10, y + h /2, x + w +10, y + h), GetStroke(SKColors.Black,1));
 canvas.DrawRect(new SKRect(x -5, y, x +1, y + h /2), GetFill(new SKColor(222,184,135)));
 canvas.DrawRect(new SKRect(x + w -1, y, x + w +5, y + h /2), GetFill(new SKColor(222,184,135)));
 {
 var roof = new[]
 {
 new SKPoint(x -15, y),
 new SKPoint(x + w +15, y),
 new SKPoint(x + w +5, y -20),
 new SKPoint(x -5, y -20)
 };
 using var path = new SKPath();
 path.AddPoly(roof, true);
 canvas.DrawPath(path, GetFill(SKColors.Crimson));
 }
 break;

 case Enums.NpcType.Teleporter:
 canvas.DrawOval(x + w /2f, y + h -8, (w +10) /2f,7.5f, GetStroke(SKColors.Cyan,2));
 canvas.DrawOval(x + w /2f, y + h -7.5f, w /2f,4.5f, GetStroke(new SKColor(0,191,255),2));
 {
 float tick = (_animCounter % 100) / 100f;
 float py = y + h -20 - (tick *40f);
 canvas.DrawOval(x + w /2f, py +2,2,2, GetFill(new SKColor(240,248,255)));
 }
 break;

 case Enums.NpcType.StorageKeeper:
 canvas.DrawRect(new SKRect(x, y +10, x + w, y + h), GetFill(new SKColor(139,69,19)));
 canvas.DrawRect(new SKRect(x, y +10, x + w, y + h), GetStroke(SKColors.Black,1));
 canvas.DrawRect(new SKRect(x +5, y +10, x +10, y + h), GetFill(new SKColor(255,215,0)));
 canvas.DrawRect(new SKRect(x + w -10, y +10, x + w -5, y + h), GetFill(new SKColor(255,215,0)));
 canvas.DrawRect(new SKRect(x + w /2f -5, y +20, x + w /2f +5, y +28), GetFill(new SKColor(255,215,0)));
 break;

 case Enums.NpcType.BlackSmith:
 canvas.DrawRect(new SKRect(x +5, y + h /2f, x + w -5, y + h), GetFill(SKColors.DimGray));
 canvas.DrawRect(new SKRect(x, y + h /2f -5, x + w, y + h /2f +5), GetFill(SKColors.Gray));
 canvas.DrawLine(x + w, y + h -5, x + w +10, y + h /2f -10, GetStroke(new SKColor(139,69,19),4));
 canvas.DrawRect(new SKRect(x + w +5, y + h /2f -15, x + w +17, y + h /2f -5), GetFill(SKColors.DarkGray));
 break;

 case Enums.NpcType.ArenaMaster:
 canvas.DrawRect(new SKRect(x + w /2f -3, y -10, x + w /2f +3, y + h), GetFill(SKColors.DarkSlateGray));
 {
 var banner = new[]
 {
 new SKPoint(x + w /2f, y -5),
 new SKPoint(x + w +10, y -5),
 new SKPoint(x + w +10, y +20),
 new SKPoint(x + w /2f +5, y +15),
 new SKPoint(x + w /2f, y +20)
 };
 using var path = new SKPath();
 path.AddPoly(banner, true);
 canvas.DrawPath(path, GetFill(SKColors.DarkRed));
 }
 break;

 default:
 canvas.DrawRect(new SKRect(x, y, x + w, y + h), GetFill(ToSK(npc.Color)));
 canvas.DrawRect(new SKRect(x, y, x + w, y + h), GetStroke(SKColors.White,1));
 break;
 }

 float tx = x + w /2f;
 float ty = y -10f;
 canvas.DrawText(npc.Name ?? string.Empty, tx +1, ty +1, _npcOutlinePaint);
 canvas.DrawText(npc.Name ?? string.Empty, tx, ty, _npcTextPaint);
 }

 private void DrawProceduralCharacterSkia(SKCanvas canvas, BattleEntity ent, SKColor color, int classType, int weaponLevel = 0, Enums.ItemGrade grade = Enums.ItemGrade.Common)
 {
 float bounce = 0f;
 float armSwing = 0f;
 float legSwing = 0f;

 if (ent.IsMoving)
 {
 bounce = MathF.Sin(ent.AnimTimer) * 2f;
 legSwing = MathF.Sin(ent.AnimTimer * 2f) * 6f;
 armSwing = MathF.Cos(ent.AnimTimer * 2f) * 8f;
 }

 float x = ent.X;
 float y = ent.Y + bounce;
 float w = ent.Width;
 float h = ent.Height;
 float cx = x + w / 2f;
 float cy = y + h / 2f;
 int dir = ent.FacingRight ? 1 : -1;

 if (classType != 0)
 canvas.DrawOval(x + w / 2f, ent.Y + h - 1, (w - 10) / 2f, 3, GetFill(new SKColor(0, 0, 0, 100)));

 var legPen = GetStroke(color, 2);
 canvas.DrawLine(cx - 4, cy + 10, cx - 4 - legSwing, cy + 22, legPen);
 canvas.DrawLine(cx + 4, cy + 10, cx + 4 + legSwing, cy + 22, legPen);

 if (classType == 1)
 {
 canvas.DrawRect(new SKRect(x, y + 5, x + w, y + h - 15), GetFill(color));
 canvas.DrawRect(new SKRect(x, y + 5, x + w, y + h - 15), GetStroke(SKColors.Black, 1));
 canvas.DrawRect(new SKRect(x, y + 15, x + w, y + 19), GetFill(new SKColor(139, 69, 19)));
 }
 else if (classType == 2)
 {
 _characterPath.Reset();
 _characterPath.MoveTo(cx - 6, y + 20);
 _characterPath.LineTo(cx + 6, y + 20);
 _characterPath.LineTo(cx + 10, y + 6);
 _characterPath.LineTo(cx - 10, y + 6);
 _characterPath.Close();
 canvas.DrawPath(_characterPath, GetFill(color));
 canvas.DrawRect(new SKRect(x + 5, y + 5, x + w - 5, y + h - 10), GetFill(new SKColor(0, 0, 0, 80)));
 }
 else
 {
 canvas.DrawOval(x + w / 2f, y + (h - 10) / 2f, (w - 4) / 2f, (h - 15) / 2f, GetFill(color));
 canvas.DrawOval(x + w / 2f, y + (h - 10) / 2f, (w - 4) / 2f, (h - 15) / 2f, GetStroke(SKColors.Black, 1));
 }

 var skin = classType == 0 ? new SKColor(188, 143, 143) : new SKColor(255, 228, 196);
 canvas.DrawOval(cx, y + 1, 9, 9, GetFill(skin));

 if (classType == 1)
 {
 _helmetPath.Reset();
 _helmetPath.AddArc(new SKRect(cx - 10, y - 9, cx + 10, y + 11), 180, 180);
 canvas.DrawPath(_helmetPath, GetFill(new SKColor(112, 128, 144)));
 }
 else if (classType == 2)
 {
 _helmetPath.Reset();
 _helmetPath.MoveTo(cx - 10, y - 5);
 _helmetPath.LineTo(cx + 10, y - 5);
 _helmetPath.LineTo(cx, y - 16);
 _helmetPath.Close();
 canvas.DrawPath(_helmetPath, GetFill(new SKColor(50, 50, 50)));
 }
 else if (classType == 3)
 {
 _helmetPath.Reset();
 _helmetPath.MoveTo(cx - 12, y - 6);
 _helmetPath.LineTo(cx + 12, y - 6);
 _helmetPath.LineTo(cx, y - 25);
 _helmetPath.Close();
 canvas.DrawPath(_helmetPath, GetFill(new SKColor(75, 0, 130)));
 }

 float eyeOff = ent.FacingRight ? 4f : -4f;
 canvas.DrawRect(new SKRect(cx + eyeOff - 2, y - 4, cx + eyeOff, y - 2), GetFill(SKColors.Black));

 if (classType > 0 || ent.VisualAttackTimer > 0)
 {
 float attackRot;
 if (ent.VisualAttackTimer > 0)
 {
 float t = 1f - (ent.VisualAttackTimer / 10f);
 attackRot = t * 90f * dir;
 attackRot -= 45f * dir;
 }
 else
 {
 attackRot = armSwing * 0.5f;
 }

 float wx = cx + (12 * dir);
 float wy = cy;

 SKColor weaponColor;
 SKColor? auraColor = null;

 if (classType > 0)
 {
 weaponColor = weaponLevel switch
 {
 >= 9 => SKColors.Cyan,
 >= 7 => new SKColor(255, 215, 0),
 >= 4 => new SKColor(119, 136, 153),
 _ => new SKColor(188, 143, 143)
 };

 auraColor = grade switch
 {
 Enums.ItemGrade.Rare => new SKColor(30, 144, 255, 100),
 Enums.ItemGrade.Epic => new SKColor(138, 43, 226, 100),
 Enums.ItemGrade.Legendary => new SKColor(255, 215, 0, 100),
 _ => null
 };
 }
 else
 {
 weaponColor = new SKColor(192, 192, 192);
 }

 canvas.Save();
 canvas.Translate(wx, wy);
 canvas.RotateDegrees(attackRot);
 if (dir == -1) canvas.Scale(-1, 1);

 if (auraColor.HasValue && classType != 0)
 canvas.DrawOval(0, 0, 5, 25, GetFill(auraColor.Value));

 if (weaponLevel >= 9 && classType > 0)
 {
 float pulse = MathF.Sin(_animCounter * 0.1f) * 2f;
 canvas.DrawOval(0, 0, 6 + pulse, 26 + pulse, GetStroke(new SKColor(255, 255, 255, 150), 2));
 }

 if (classType == 1)
 {
 canvas.DrawRect(new SKRect(0, -20, 4, 10), GetFill(weaponColor));
 canvas.DrawRect(new SKRect(-4, 0, 8, 2), GetFill(new SKColor(165, 42, 42)));
 canvas.DrawRect(new SKRect(0, 10, 4, 16), GetFill(new SKColor(165, 42, 42)));
 }
 else if (classType == 2)
 {
 canvas.DrawRect(new SKRect(0, -10, 3, 6), GetFill(weaponColor));
 }
 else if (classType == 3)
 {
 canvas.DrawRect(new SKRect(-2, -25, 2, 25), GetFill(new SKColor(139, 69, 19)));
 var orb = weaponLevel >= 9 ? SKColors.Cyan : SKColors.Red;
 canvas.DrawOval(0, -23, 6, 6, GetFill(orb));
 }
 else
 {
 canvas.DrawRect(new SKRect(-2, -15, 4, 10), GetFill(SKColors.DarkGray));
 }

 canvas.Restore();
 }
 }

 private void DrawEffectsSkia(SKCanvas canvas)
 {
 int effectCount = _effects.Count;
 for (int i = effectCount - 1; i >= 0; i--)
 {
 var effect = _effects[i];

 float progress = 0f;
 if (effect.InitialLifeTime > 0)
 progress = 1f - ((float)effect.LifeTime / effect.InitialLifeTime);
 else if (effect.LifeTime > 0)
 progress = 1f - (effect.LifeTime / 60f);

 int alpha = Math.Min(255, effect.LifeTime * 8);
 alpha = Math.Clamp(alpha, 0, 255);
 var c = ToSK(effect.Color).WithAlpha((byte)alpha);

 if (effect.IsText)
 {
 float yOffset = progress * 15f;
 float textSize = effect.Size >= 14 ? 28 : 22;
 
 _effectTextPaint.Color = c;
 _effectTextPaint.TextSize = textSize;

 if (effect.Color == Color.Gold)
 {
 _effectTextOutlinePaint.Color = new SKColor(0, 0, 0, (byte)alpha);
 _effectTextOutlinePaint.TextSize = textSize;
 canvas.DrawText(effect.Text ?? string.Empty, effect.X - 1, effect.Y - 1 - yOffset, _effectTextOutlinePaint);
 canvas.DrawText(effect.Text ?? string.Empty, effect.X + 1, effect.Y + 1 - yOffset, _effectTextOutlinePaint);
 }

 canvas.DrawText(effect.Text ?? string.Empty, effect.X, effect.Y - yOffset, _effectTextPaint);
 continue;
 }

 if (effect.EffectType == 3)
 {
 float maxLife = effect.InitialLifeTime > 0 ? effect.InitialLifeTime : 60f;
 float ringProgress = 1f - (Math.Max(0, effect.LifeTime) / maxLife);
 float ringSize = effect.Size + (ringProgress * 80f);
 int ringAlpha = (int)(255 * (1f - ringProgress));
 ringAlpha = Math.Clamp(ringAlpha, 0, 255);

 canvas.DrawOval(effect.X, effect.Y, ringSize / 2, ringSize / 2, GetStroke(ToSK(effect.Color).WithAlpha((byte)ringAlpha), 3));
 float innerSize = ringSize * 0.6f;
 canvas.DrawOval(effect.X, effect.Y, innerSize / 2, innerSize / 2, GetStroke(ToSK(effect.Color).WithAlpha((byte)(ringAlpha / 2)), 2));
 continue;
 }

 if (effect.EffectType == 1)
 {
 float hitSize = effect.Size * (1f + progress * 0.3f);
 canvas.DrawOval(effect.X, effect.Y, hitSize / 2, hitSize / 2, GetFill(c));
 continue;
 }

 if (effect.EffectType == 2)
 {
 float puffSize = effect.Size * (1f + progress * 2f);
 int puffAlpha = (int)(alpha * (1f - progress * 0.8f));
 var pc = ToSK(effect.Color).WithAlpha((byte)Math.Clamp(puffAlpha, 0, 255));
 canvas.DrawOval(effect.X, effect.Y, puffSize / 2, puffSize / 2, GetFill(pc));
 continue;
 }

 // fallback
 canvas.DrawOval(effect.X, effect.Y, effect.Size / 2, effect.Size / 2, GetFill(c));
 }
 }

 private void DrawHotbarSkia(SKCanvas canvas)
 {
 for (int i =0; i < _hotbar.Count; i++)
 {
 var rect = GetHotbarSlotRect(i);
 var slot = _hotbar[i];

 canvas.DrawRect(rect.X, rect.Y, rect.Width, rect.Height, GetFill(new SKColor(50,50,50,255)));
 canvas.DrawRect(rect.X, rect.Y, rect.Width, rect.Height, GetStroke(SKColors.DimGray,1));

 if (slot.Type ==0 && slot.Item != null)
 {
 var color = ToSK(GetHotbarColor(slot.Item.Grade, slot.Item.ItemType));
 canvas.DrawRect(rect.X +2, rect.Y +2, rect.Width -4, rect.Height -4, GetFill(color.WithAlpha(50)));

 var skBmp = GetHotbarBitmap(slot.CachedImage);
 if (skBmp != null)
 {
 canvas.DrawBitmap(skBmp, new SKRect(rect.X +2, rect.Y +2, rect.Right -2, rect.Bottom -2));
 }

 if (slot.Item.Count >1)
 {
 canvas.DrawText(slot.Item.Count.ToString(), rect.Right -20, rect.Bottom -5, _hotbarCountPaint);
 }

 if (slot.Item.RemainingCooldownExact >0)
 {
 float frac = (float)(slot.Item.RemainingCooldownExact / (double)slot.Item.Cooldown);
 using var path = new SKPath();
 path.MoveTo(rect.X + rect.Width /2f, rect.Y + rect.Height /2f);
 path.ArcTo(new SKRect(rect.X +6, rect.Y +6, rect.Right -6, rect.Bottom -6), -90,360f * frac, false);
 path.Close();
 canvas.DrawPath(path, _cooldownFillPaint);
 }
 }
 else if (slot.Type ==1 && slot.Skill != null)
 {
 canvas.DrawRect(rect.X +2, rect.Y +2, rect.Width -4, rect.Height -4, GetFill(new SKColor(72,61,139,50)));

 var skBmp = GetHotbarBitmap(slot.CachedImage);
 if (skBmp != null)
 {
 canvas.DrawBitmap(skBmp, new SKRect(rect.X +2, rect.Y +2, rect.Right -2, rect.Bottom -2));
 }

 canvas.DrawText(slot.Skill.ManaCost.ToString(), rect.X +2, rect.Bottom -3, _hotbarManaPaint);

 if (slot.Skill.RemainingCooldown >0)
 {
 float frac = (float)(slot.Skill.RemainingCooldown / slot.Skill.Cooldown);
 using var path = new SKPath();
 path.MoveTo(rect.X + rect.Width /2f, rect.Y + rect.Height /2f);
 path.ArcTo(new SKRect(rect.X +6, rect.Y +6, rect.Right -6, rect.Bottom -6), -90,360f * frac, false);
 path.Close();
 canvas.DrawPath(path, _cooldownFillPaint);

 if (slot.Skill.RemainingCooldown >1.0)
 {
 string s = Math.Ceiling(slot.Skill.RemainingCooldown).ToString();
 canvas.DrawText(s, rect.X + rect.Width /2f, rect.Y + rect.Height /2f +7, _hotbarCooldownTextPaint);
 }
 }
 }

 canvas.DrawText((i +1).ToString(), rect.X +2, rect.Y +18, _hotbarIndexPaint);
 }
 }

 private SKColor GetTitleColor(bool won) => won ? new SKColor(255,215,0) : SKColors.Red;

 private void DrawResultsOverlaySkia(SKCanvas canvas, int w, int h)
 {
 canvas.DrawRect(new SKRect(0,0, w, h), GetFill(new SKColor(0,0,0,220)));

 bool won = _player != null && _player.CurrentHP >0;
 string title = won ? "ZAFER!" : DefeatTitle;

 using var titlePaint = new SKPaint { Color = GetTitleColor(won), TextSize =72, IsAntialias = false, FakeBoldText = true, TextAlign = SKTextAlign.Center };
 canvas.DrawText(title, w /2f, h *0.2f +72, titlePaint);

 using var msgPaint = new SKPaint { Color = SKColors.White, TextSize =24, IsAntialias = false, TextAlign = SKTextAlign.Center };
 canvas.DrawText(_resultMessage ?? string.Empty, w /2f, h *0.2f +72 +50, msgPaint);

 // Buttons
 int btnW =220;
 int btnH =52;
 int gap =18;
 int y = (int)(h *0.65f);

 bool hasSecondary = !string.IsNullOrWhiteSpace(_secondaryBtnText) && _onSecondary != null;
 int totalW = hasSecondary ? (btnW *2 + gap) : btnW;
 int startX = (w - totalW) /2;

 _primaryBtnRect = new Rectangle(startX, y, btnW, btnH);
 _secondaryBtnRect = hasSecondary ? new Rectangle(startX + btnW + gap, y, btnW, btnH) : Rectangle.Empty;

 DrawResultsButton(canvas, _primaryBtnRect, _primaryBtnText, filled: true);
 if (hasSecondary)
 DrawResultsButton(canvas, _secondaryBtnRect, _secondaryBtnText, filled: false);
 }

 private void DrawBuffsSkia(SKCanvas canvas)
 {
 var buffs = NotificationManager.GetBuffs();
 int startX =20;
 int startY =20;

 for (int i =0; i < buffs.Count; i++)
 {
 var buff = buffs[i];
 int boxSize =32;
 var rect = new SKRect(startX, startY + (i * (boxSize +5)), startX + boxSize, startY + (i * (boxSize +5)) + boxSize);

 canvas.DrawRect(rect, GetFill(new SKColor(0,0,0,100)));
 canvas.DrawRect(rect, GetStroke(SKColors.Gray,1));

 if (buff.IconType == "ManaRegen")
 canvas.DrawOval(rect.MidX, rect.MidY,8,8, GetFill(SKColors.DodgerBlue));
 else if (buff.IconType == "Success")
 canvas.DrawOval(rect.MidX, rect.MidY,8,8, GetFill(SKColors.LimeGreen));
 }
 }

 private void DrawNotificationsSkia(SKCanvas canvas)
 {
 var notifs = NotificationManager.GetNotifications();
 int startX = 20;
 int startY = 200;
 int notifCount = notifs.Count;

 for (int i = 0; i < notifCount; i++)
 {
 var notif = notifs[i];
 int alpha = 255;
 if (notif.Duration < 30) alpha = (int)((notif.Duration / 30f) * 255);
 alpha = Math.Clamp(alpha, 0, 255);

 _notificationPaint.Color = ToSK(notif.Color).WithAlpha((byte)alpha);
 var msg = notif.Message ?? string.Empty;
 var sz = _notificationPaint.MeasureText(msg);
 canvas.DrawRect(new SKRect(startX - 2, startY + (i * 25) - 2, startX - 2 + sz + 8, startY + (i * 25) + 22),
 GetFill(new SKColor(0, 0, 0, (byte)(alpha * 0.7f))));
 canvas.DrawText(msg, startX, startY + (i * 25) + 18, _notificationPaint);
 }
 }

 private void DisposeSkiaCaches()
 {
 _skBackgroundCache?.Dispose();
 _skBackgroundCache = null;

 foreach (var kv in _skFillPaintCache) kv.Value.Dispose();
 foreach (var kv in _skStrokePaintCache) kv.Value.Dispose();
 _skFillPaintCache.Clear();
 _skStrokePaintCache.Clear();

 foreach (var kv in _hotbarSkBitmapCache) kv.Value.Dispose();
 _hotbarSkBitmapCache.Clear();

 _enemyNameTextPaint?.Dispose();
 _hotbarCountPaint?.Dispose();
 _hotbarIndexPaint?.Dispose();
 _hotbarManaPaint?.Dispose();
 _hotbarCooldownTextPaint?.Dispose();
 _cooldownFillPaint?.Dispose();
 _resultsButtonTextPaint?.Dispose();
 _effectTextPaint?.Dispose();
 _effectTextOutlinePaint?.Dispose();
 _notificationPaint?.Dispose();
 _npcOutlinePaint?.Dispose();
 _npcTextPaint?.Dispose();
 _characterPath?.Dispose();
 _helmetPath?.Dispose();
 }

 private void DrawResultsButton(SKCanvas canvas, Rectangle rect, string text, bool filled)
 {
 var r = new SKRect(rect.Left, rect.Top, rect.Right, rect.Bottom);
 var bg = filled ? new SKColor(30,144,255,220) : new SKColor(0,0,0,0);
 var border = filled ? SKColors.Transparent : new SKColor(200,200,200,220);

 if (filled)
 canvas.DrawRoundRect(r,10,10, GetFill(bg));

 canvas.DrawRoundRect(r,10,10, GetStroke(border,2));

 float cx = rect.Left + rect.Width /2f;
 float cy = rect.Top + rect.Height /2f +7;
 canvas.DrawText(text ?? string.Empty, cx, cy, _resultsButtonTextPaint);
 }
}
