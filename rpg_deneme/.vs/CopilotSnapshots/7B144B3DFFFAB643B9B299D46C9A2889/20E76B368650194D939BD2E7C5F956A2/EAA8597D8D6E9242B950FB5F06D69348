using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using rpg_deneme.Business;
using rpg_deneme.Core;
using rpg_deneme.Models;
using rpg_deneme.UI.Controls.GameEntities;
using SkillProjectile = rpg_deneme.UI.Controls.GameEntities.SkillProjectile;
using SkiaSharp.Views.Desktop;

namespace rpg_deneme.UI.Controls;

public partial class UcArena : UserControl
{
    private ArenaPanel _arena;

    // OpenGL-backed renderer
    private SKGLControl _skgl;

    private Timer _gameLoop;

    private Random _rnd = new Random();

    private List<HotbarSlot> _hotbar = new List<HotbarSlot>();

    private BattleEntity _player;

    private List<BattleEntity> _enemies = new List<BattleEntity>();

    // Projectile list should use the GameEntities implementation
    private List<SkillProjectile> _projectiles = new List<SkillProjectile>();

    private List<VisualEffect> _effects = new List<VisualEffect>();

    private CharacterModel _hero;

    private List<SkillModel> _learnedSkills = new List<SkillModel>();

    private InventoryManager _invManager = new InventoryManager();

    private Button _btnMap;

    private bool _isTownMode = false;

    private List<NpcEntity> _npcs = new List<NpcEntity>();

    private bool _w;

    private bool _a;

    private bool _s;

    private bool _d;

    private Point _mousePos = Point.Empty;

    private int _attackDelayMs = 1000;

    private DateTime _lastAttackTime = DateTime.MinValue;

    private int _manaCostPerHit = 0;

    private bool _isBattleEnding = false;

    private int _enemyAttackCooldown = 0;

    private IContainer components = null;

    // Optimization & Visuals
    private Dictionary<Color, SolidBrush> _brushCache;
    private Dictionary<Color, Pen> _penCache;

    // Zero-allocation (hot path): frequently used brushes/pens as readonly fields
    // NOTE: These will be disposed in `Dispose(bool)`.
    private readonly SolidBrush _brushWhite = new(Color.White);
    private readonly SolidBrush _brushBlack = new(Color.Black);
    private readonly SolidBrush _brushGold = new(Color.Gold);
    private readonly SolidBrush _brushDimGray = new(Color.DimGray);
    private readonly SolidBrush _brushDarkGray = new(Color.DarkGray);
    private readonly SolidBrush _brushOrangeRed = new(Color.OrangeRed);
    private readonly SolidBrush _brushLightCyan = new(Color.LightCyan);
    private readonly SolidBrush _brushMediumPurple = new(Color.MediumPurple);
    private readonly SolidBrush _brushDodgerBlue = new(Color.DodgerBlue);
    private readonly SolidBrush _brushLimeGreen = new(Color.LimeGreen);

    private readonly Pen _penBlack1 = new(Color.Black, 1f);
    private readonly Pen _penDimGray1 = new(Color.DimGray, 1f);
    private readonly Pen _penGray1 = new(Color.Gray, 1f);
    private readonly Pen _penWhite1 = new(Color.White, 1f);
    private readonly Pen _penGold2 = new(Color.Gold, 2f);

    private int _shakeDuration = 0;
    private int _shakeMagnitude = 0;
    private int _currentWeaponUpgradeLevel = 0;
    private Enums.ItemGrade _currentWeaponGrade = Enums.ItemGrade.Common;

    // Performance: Animation Counter (avoid DateTime.Now)
    private int _animCounter = 0;

    // Performance: Cached Fonts
    private readonly Font _damageFont = new Font("Segoe UI", 11f, FontStyle.Bold);
    private readonly Font _critDamageFont = new Font("Segoe UI", 14f, FontStyle.Bold);
    private readonly Font _enemyNameFont = new Font("Segoe UI", 7f, FontStyle.Regular);
    private readonly StringFormat _centerFormat = new StringFormat { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center };

    // Mana Regen
    private int _manaRegenAmount = 0;
    private int _manaRegenTimer = 0;

    // Equipment Cache
    private List<ItemInstance> _cachedEquipment;
    private DateTime _lastEquipFetchTime;

    // Stats refresh (equipment changes during battle)
    private DateTime _lastStatsRefreshTime = DateTime.MinValue;
    private const int StatsRefreshIntervalMs = 500;

    // Results UI
    private bool _showResults = false;
    private string _resultMessage = "";

    private Action _onPrimary = null;
    private string _primaryBtnText = "DEVAM ET";
    private Rectangle _primaryBtnRect;

    private Action _onSecondary = null;
    private string _secondaryBtnText = "";
    private Rectangle _secondaryBtnRect;

    // Tooltip State
    private int _lastHoveredBuffIndex = -1;
    private int _lastHoveredHotbarIndex = -1;

    public event EventHandler OnMapRequested;

    public event EventHandler<bool> OnBattleEnded;

    public event EventHandler OnStatsUpdated;

    public event EventHandler<NpcEntity> OnNpcInteraction;

    // Enemy neighbor acceleration (reduces O(n^2) separation cost)
    private readonly EnemySpatialGrid _enemyGrid = new EnemySpatialGrid();

    // Idle-based game loop (replaces WinForms Timer jitter)
    private bool _loopRunning;
    private readonly Stopwatch _loopWatch = Stopwatch.StartNew();
    private long _loopLastTicks;
    private double _loopAccum;
    private const double FixedDt = 1.0 / 60.0;
    private const double MaxFrameClamp = 0.25; // avoid spiral of death

    // Cap render/idle pumping to60fps so we don't spin the message loop at hundreds/thousands of fps.
    private long _loopLastRenderTicks;
    private static readonly long RenderFrameTicks = Stopwatch.Frequency / 60;

    [StructLayout(LayoutKind.Sequential)]
    private struct NativeMessage
    {
        public nint Handle;
        public uint Msg;
        public nint WParam;
        public nint LParam;
        public uint Time;
        public Point P;
    }

    [DllImport("user32.dll")]
    private static extern bool PeekMessage(out NativeMessage lpMsg, nint hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

    private static bool AppStillIdle => !PeekMessage(out _, nint.Zero, 0, 0, 0);

    public UcArena()
    {
        DoubleBuffered = true;
        // GDI+ Resource Caching
        _brushCache = new Dictionary<Color, SolidBrush>();
        _penCache = new Dictionary<Color, Pen>();

        BackColor = Color.Black;
        SetupArena();
    }

    private void SetupArena()
    {
        _arena = new ArenaPanel();
        _arena.Dock = DockStyle.Fill;
        _arena.BackColor = Color.FromArgb(45, 45, 48);

        // Use SkiaSharp GL surface for painting
        _skgl = new SKGLControl
        {
            Dock = DockStyle.Fill,
            BackColor = Color.FromArgb(45, 45, 48)
        };
        _skgl.PaintSurface += Arena_SKPaintSurface;

        // Forward mouse/drag events
        _skgl.MouseDown += Arena_MouseDown;
        _skgl.MouseMove += delegate (object? s, MouseEventArgs e)
        {
            _mousePos = e.Location;
            UpdateTooltips(e.Location);
        };
        _skgl.AllowDrop = true;
        _skgl.DragEnter += Arena_DragEnter;
        _skgl.DragDrop += Arena_DragDrop;

        _arena.Controls.Add(_skgl);
        base.Controls.Add(_arena);

        base.Click += delegate { Focus(); };

        for (int i = 0; i < 5; i++)
        {
            _hotbar.Add(new HotbarSlot
            {
                Index = i
            });
        }
    }

    public (int, int) GetArenaSize()
    {
        if (_skgl == null) return (0, 0);
        return (_skgl.Width, _skgl.Height);
    }

    private Rectangle GetHotbarSlotRect(int index)
    {
        var (w, h) = GetArenaSize();
        int slotSize = 50;
        int gap = 10;
        int totalW = (5 * slotSize) + (4 * gap);
        int startX = (w - totalW) / 2;
        int y = h - slotSize - 20;

        return new Rectangle(startX + (index * (slotSize + gap)), y, slotSize, slotSize);
    }

    private static float Lerp(float a, float b, float t)
    {
        return a + (b - a) * t;
    }

    private float Distance(float x1, float y1, float x2, float y2)
    {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return (float)Math.Sqrt(dx * dx + dy * dy);
    }

    private float DistanceSquared(float x1, float y1, float x2, float y2)
    {
        float dx = x2 - x1;
        float dy = y2 - y1;
        return dx * dx + dy * dy;
    }

    private void ClampEntityPosition(BattleEntity entity)
    {
        if (entity != null)
        {
            var (w, h) = GetArenaSize();
            if (entity.X < 0f) entity.X = 0f;
            if (entity.X > (float)(w - entity.Width)) entity.X = w - entity.Width;
            if (entity.Y < 0f) entity.Y = 0f;
            if (entity.Y > (float)(h - entity.Height)) entity.Y = h - entity.Height;
        }
    }

    private List<ItemInstance> GetEquipment()
    {
        if (_hero == null) return _cachedEquipment ?? new List<ItemInstance>();

        if (_cachedEquipment == null || (DateTime.Now - _lastEquipFetchTime).TotalSeconds > 1)
        {
            var inv = _invManager.GetInventory(_hero.CharacterID);
            _cachedEquipment = inv.FindAll(x => x.Location == Enums.ItemLocation.Equipment);
            _lastEquipFetchTime = DateTime.Now;
        }
        return _cachedEquipment;
    }

    private void InvalidateEquipmentCache()
    {
        _cachedEquipment = null;
        _lastEquipFetchTime = DateTime.MinValue;
    }

    protected override void Dispose(bool disposing)
    {
        if (disposing)
        {
            StopGameLoop();

            if (components != null) components.Dispose();
            // Clear Caches
            foreach (var b in _brushCache.Values) b.Dispose();
            foreach (var p in _penCache.Values) p.Dispose();
            _brushCache.Clear();
            _penCache.Clear();

            // Dispose zero-allocation brushes/pens
            _brushWhite.Dispose();
            _brushBlack.Dispose();
            _brushGold.Dispose();
            _brushDimGray.Dispose();
            _brushDarkGray.Dispose();
            _brushOrangeRed.Dispose();
            _brushLightCyan.Dispose();
            _brushMediumPurple.Dispose();
            _brushDodgerBlue.Dispose();
            _brushLimeGreen.Dispose();

            _penBlack1.Dispose();
            _penDimGray1.Dispose();
            _penGray1.Dispose();
            _penWhite1.Dispose();
            _penGold2.Dispose();

            _enemyNameFont?.Dispose();
            _centerFormat?.Dispose();
            _damageFont?.Dispose();
            _critDamageFont?.Dispose();

            DisposeSkiaCaches();

            if (_skgl != null)
            {
                _skgl.PaintSurface -= Arena_SKPaintSurface;
                _skgl.Dispose();
                _skgl = null;
            }
        }
        base.Dispose(disposing);
    }

    private void InitializeComponent()
    {
        this.components = new System.ComponentModel.Container();
        base.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    }
}
