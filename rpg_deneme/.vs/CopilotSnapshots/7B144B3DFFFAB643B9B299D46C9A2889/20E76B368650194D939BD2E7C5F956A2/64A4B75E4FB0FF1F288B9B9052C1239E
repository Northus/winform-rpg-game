using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using rpg_deneme.Business;
using rpg_deneme.Core;
using rpg_deneme.Models;
using rpg_deneme.Data;
using rpg_deneme.UI.Controls.GameEntities;
using SkillProjectile = rpg_deneme.UI.Controls.GameEntities.SkillProjectile;

namespace rpg_deneme.UI.Controls;

public partial class UcArena
{
    public void StartBattle(CharacterModel hero, BattleEntity enemyTemplate)
    {
        PrepareBattleCommon(hero);
        BattleEntity singleEnemy = new BattleEntity
        {
            X = base.Width - 100,
            Y = base.Height / 2 - 20,
            Width = enemyTemplate.Width,
            Height = enemyTemplate.Height,
            Speed = enemyTemplate.Speed,
            MaxHP = enemyTemplate.MaxHP,
            CurrentHP = enemyTemplate.MaxHP,
            MinDamage = enemyTemplate.MinDamage,
            MaxDamage = enemyTemplate.MaxDamage,
            Name = enemyTemplate.Name,
            IsRanged = enemyTemplate.IsRanged,
            AttackRange = enemyTemplate.AttackRange
        };
        if (_player != null)
        {
            Rectangle playerRect = new Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height);
            Rectangle enemyRect = new Rectangle((int)singleEnemy.X, (int)singleEnemy.Y, singleEnemy.Width, singleEnemy.Height);
            int tries = 0;
            Random rnd = new Random();
            while (enemyRect.IntersectsWith(playerRect) && tries < 20)
            {
                singleEnemy.X = base.Width - 100 - rnd.Next(0, 200);
                singleEnemy.Y = 100 + rnd.Next(0, Math.Max(100, base.Height - 200));
                enemyRect = new Rectangle((int)singleEnemy.X, (int)singleEnemy.Y, singleEnemy.Width, singleEnemy.Height);
                tries++;
            }
        }
        _enemies.Add(singleEnemy);
        StartGameLoop();
    }

    public void StartSurvivalBattle(CharacterModel hero, List<EnemyModel> enemyTemplates)
    {
        PrepareBattleCommon(hero);
        (int, int) arenaSize = GetArenaSize();
        int w = arenaSize.Item1;
        int h = arenaSize.Item2;
        Random rnd = new Random();
        foreach (EnemyModel tmpl in enemyTemplates)
        {
            int ex = w - 100 - rnd.Next(0, 200);
            int ey = 100 + rnd.Next(0, Math.Max(100, h - 200));
            bool isRangedUnit = tmpl.IsRanged || tmpl.Type == Enums.EnemyType.Ranged;
            int attackRange = ((tmpl.AttackRange > 0) ? tmpl.AttackRange : (isRangedUnit ? 250 : 50));
            BattleEntity newEnemy = new BattleEntity
            {
                X = ex,
                Y = ey,
                Width = tmpl.Width,
                Height = tmpl.Height,
                Speed = tmpl.Speed,
                MaxHP = tmpl.MaxHP,
                CurrentHP = tmpl.MaxHP,
                MinDamage = tmpl.MinDamage,
                MaxDamage = tmpl.MaxDamage,
                Name = tmpl.Name,
                IsRanged = isRangedUnit,
                AttackRange = attackRange
            };
            if (_player != null)
            {
                Rectangle playerRect = new Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height);
                Rectangle eRect = new Rectangle((int)newEnemy.X, (int)newEnemy.Y, newEnemy.Width, newEnemy.Height);
                int tries = 0;
                while ((eRect.IntersectsWith(playerRect) || _enemies.Any((BattleEntity en) => en.Bounds.IntersectsWith(eRect))) && tries < 30)
                {
                    ex = w - 100 - rnd.Next(0, 300);
                    ey = 80 + rnd.Next(0, Math.Max(100, h - 160));
                    newEnemy.X = ex;
                    newEnemy.Y = ey;
                    eRect = new Rectangle((int)newEnemy.X, (int)newEnemy.Y, newEnemy.Width, newEnemy.Height);
                    tries++;
                }
            }
            _enemies.Add(newEnemy);
        }
        StartGameLoop();
    }

    public void StartTown(CharacterModel hero)
    {
        _isBattleEnding = false;
        _hero = hero;
        LoadHotbarFromSession();
        _isTownMode = true;
        _projectiles.Clear();
        _enemies.Clear();
        _w = (_a = (_s = (_d = false)));
        InitTownEntities();
        UpdateTownLayout();
        (int, int) arenaSize = GetArenaSize();
        int w = arenaSize.Item1;
        int h = arenaSize.Item2;

        List<ItemInstance> inventory = _invManager.GetInventory(_hero.CharacterID);
        List<ItemInstance> equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
        int maxHp = StatManager.CalculateTotalMaxHP(_hero, equippedItems);

        int currentHP = _hero.HP;
        if (currentHP > maxHp) currentHP = maxHp;
        if (currentHP < 0) currentHP = 0;

        _player = new BattleEntity
        {
            X = w / 2 - 16,
            Y = h / 2 - 16,
            Width = 32,
            Height = 32,
            Speed = 5f,
            MaxHP = maxHp,
            CurrentHP = currentHP,
            MinDamage = 0,
            MaxDamage = 0,
            Defense = 0
        };

        _hero.HP = currentHP;
        StartGameLoop();
    }

    private void PrepareBattleCommon(CharacterModel hero)
    {
        _hero = hero;
        LoadHotbarFromSession();
        _projectiles.Clear();
        _enemies.Clear();
        _w = (_a = (_s = (_d = false)));
        _isBattleEnding = false;
        _isTownMode = false;

        List<ItemInstance> inventory = _invManager.GetInventory(_hero.CharacterID);
        List<ItemInstance> equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
        int maxHp = StatManager.CalculateTotalMaxHP(_hero, equippedItems);

        int currentHP = _hero.HP;

        if (currentHP > maxHp)
        {
            currentHP = maxHp;
        }
        if (currentHP < 0)
        {
            currentHP = 0;
        }

        (int, int) arenaSize = GetArenaSize();
        int arenaW = arenaSize.Item1;
        int arenaH = arenaSize.Item2;
        int startX = Math.Max(0, arenaW / 2 - 16);
        int startY = Math.Max(0, arenaH / 2 - 16);
        _player = new BattleEntity
        {
            X = startX,
            Y = startY,
            Width = 32,
            Height = 32,
            Speed = 5f,
            MaxHP = maxHp,
            CurrentHP = currentHP,
            MinDamage = 0,
            MaxDamage = 0,
            Defense = 0
        };

        _hero.HP = currentHP;
        RecalculatePlayerStats();

        if (_player.CurrentHP > _player.MaxHP)
        {
            _player.CurrentHP = _player.MaxHP;
            _hero.HP = _player.MaxHP;
        }
    }

    public void RecalculatePlayerStats()
    {
        if (_hero != null && _player != null)
        {
            SkillManager skillMgr = new SkillManager();
            _learnedSkills = skillMgr.LoadSkillsForClass((Enums.CharacterClass)_hero.Class, _hero.CharacterID);

            foreach (var slot in _hotbar)
            {
                if (slot.Type == 1 && slot.Skill != null)
                {
                    var freshSkill = _learnedSkills.FirstOrDefault(s => s.SkillID == slot.Skill.SkillID);
                    if (freshSkill != null)
                    {
                        freshSkill.LastCastTime = slot.Skill.LastCastTime;
                        slot.Skill = freshSkill;
                    }
                }
            }

            List<ItemInstance> inventory = _invManager.GetInventory(_hero.CharacterID);
            ItemInstance equippedWeapon = inventory.FirstOrDefault((ItemInstance x) => x.Location == Enums.ItemLocation.Equipment && x.ItemType == Enums.ItemType.Weapon);
            _currentWeaponUpgradeLevel = (equippedWeapon != null) ? equippedWeapon.UpgradeLevel : 0;
            _currentWeaponGrade = (equippedWeapon != null) ? equippedWeapon.Grade : Enums.ItemGrade.Common;
            List<ItemInstance> equippedItems = inventory.Where((ItemInstance x) => x.Location == Enums.ItemLocation.Equipment).ToList();

            (int, int) calculatedDamage = ((_hero.Class == 3)
                ? StatManager.CalculateMagicalDamage(_hero, equippedWeapon, _learnedSkills)
                : StatManager.CalculatePhysicalDamage(_hero, equippedWeapon, _learnedSkills));
            int calculatedDefense = StatManager.CalculateTotalDefense(_hero, equippedItems, _learnedSkills);

            _attackDelayMs = StatManager.CalculateAttackDelay(_hero, equippedItems, _learnedSkills);
            _manaCostPerHit = StatManager.CalculateAttackManaCost(_hero);
            _player.MinDamage = calculatedDamage.Item1;
            _player.MaxDamage = calculatedDamage.Item2;
            _player.Defense = calculatedDefense;

            int moveSpeedBonus = StatManager.CalculateMovementSpeedBonus(_learnedSkills);
            _player.Speed = 5f + moveSpeedBonus * 0.1f;

            _manaRegenAmount = StatManager.GetTotalAttributeValue(equippedItems, Enums.ItemAttributeType.ManaRegen);

            var passiveBonus = StatManager.CalculatePassiveBonuses(_learnedSkills);
            _manaRegenAmount += (int)passiveBonus.ManaRegenBonus;

            NotificationManager.ClearBuffs();
            if (_manaRegenAmount > 0) NotificationManager.AddBuff($"Mana Regen: {_manaRegenAmount}/3sn", "ManaRegen", _manaRegenAmount);

            int newMaxHP = StatManager.CalculateTotalMaxHP(_hero, equippedItems, _learnedSkills);
            int oldMaxHP = _player.MaxHP;
            _player.MaxHP = newMaxHP;
            if (oldMaxHP > 0 && newMaxHP != oldMaxHP && _player.CurrentHP > newMaxHP)
            {
                _player.CurrentHP = newMaxHP;
                _hero.HP = newMaxHP;
            }
            if (_player.CurrentHP > _player.MaxHP)
            {
                _player.CurrentHP = _player.MaxHP;
                _hero.HP = _player.MaxHP;
            }

            int newMaxMana = StatManager.CalculateTotalMaxMana(_hero, equippedItems, _learnedSkills);
            _player.MaxMana = newMaxMana;
            if (_hero.Mana > newMaxMana) _hero.Mana = newMaxMana;
            _player.CurrentMana = _hero.Mana;
        }
    }

    private void StartGameLoop()
    {
        // Stop old timer loop if it exists

        if (_loopRunning) return;

        _loopRunning = true;
        _loopLastTicks = _loopWatch.ElapsedTicks;
        _loopAccum = 0;
        _loopLastRenderTicks = _loopLastTicks;

        Application.Idle -= GameLoop_OnIdle;
        Application.Idle += GameLoop_OnIdle;

        Focus();
    }

    private void StopGameLoop()
    {
        if (!_loopRunning) return;
        _loopRunning = false;
        Application.Idle -= GameLoop_OnIdle;
    }

    private void GameLoop_OnIdle(object? sender, EventArgs e)
    {
        // Amortize PeekMessage calls - check less frequently to reduce overhead
        while (_loopRunning && AppStillIdle)
        {
            var nowTicks = _loopWatch.ElapsedTicks;
            var delta = (nowTicks - _loopLastTicks) / (double)Stopwatch.Frequency;
            _loopLastTicks = nowTicks;

            if (delta > MaxFrameClamp) delta = MaxFrameClamp;
            _loopAccum += delta;

            // Process fixed timestep updates
            int safety = 0;
            while (_loopAccum >= FixedDt && safety++ < 10)
            {
                StepSimulation();
                _loopAccum -= FixedDt;
            }

            // Render throttled to 60fps
            if (nowTicks - _loopLastRenderTicks >= RenderFrameTicks)
            {
                _loopLastRenderTicks = nowTicks;
                _skgl?.Invalidate();
            }

            // Exit loop to let WinForms process messages - no Thread.Yield needed
            // The outer while condition (AppStillIdle) handles message checking
            break;
        }
    }

    // One fixed-step simulation tick (60Hz)
    private void StepSimulation()
    {
        Fps_OnGameTick();

        if (_player == null) return;

        if (_isBattleEnding)
        {
            UpdateEffects();
            return;
        }

        // Keep hero<->player resources in sync
        if (_hero != null)
        {
            // Periodically refresh stats so equipment / passive changes during battle apply immediately.
            // (Inventory UIs can change equipment while battle is running, so we cannot rely only on battle start.)
            if ((DateTime.Now - _lastStatsRefreshTime).TotalMilliseconds >= StatsRefreshIntervalMs)
            {
                InvalidateEquipmentCache();
                RecalculatePlayerStats();
                _lastStatsRefreshTime = DateTime.Now;

                // clamp hero resources in case max values changed
                if (_hero.HP > _player.MaxHP) _hero.HP = _player.MaxHP;
                if (_hero.Mana > _player.MaxMana) _hero.Mana = _player.MaxMana;
            }

            if (_hero.HP != _player.CurrentHP)
            {
                _player.CurrentHP = _hero.HP;
            }

            if (_player.CurrentHP > _player.MaxHP)
            {
                _player.CurrentHP = _player.MaxHP;
                _hero.HP = _player.MaxHP;
            }

            if (_hero.Mana != _player.CurrentMana)
            {
                _player.CurrentMana = _hero.Mana;
            }

            if (_player.CurrentMana > _player.MaxMana)
            {
                _player.CurrentMana = _player.MaxMana;
                _hero.Mana = _player.MaxMana;
            }

            _manaRegenTimer++;
            if (_manaRegenTimer >= 60)
            {
                _manaRegenTimer = 0;
                if (_manaRegenAmount > 0 && _player.CurrentMana < _player.MaxMana)
                {
                    _player.CurrentMana += _manaRegenAmount;
                    if (_player.CurrentMana > _player.MaxMana) _player.CurrentMana = _player.MaxMana;
                    _hero.Mana = _player.CurrentMana;
                    this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
                }
            }
        }

        if (_shakeDuration > 0)
        {
            _shakeDuration--;
        }

        _animCounter++;
        if (_animCounter > 10000) _animCounter = 0;

        NotificationManager.Update();

        UpdatePlayer();
        UpdateProjectiles();
        UpdateEffects();
        if (!_isTownMode)
        {
            UpdateEnemies();
        }
    }

    private void UpdateEnemies()
    {
        if (_enemyAttackCooldown > 0)
        {
            _enemyAttackCooldown--;
        }

        int aliveCount = 0;
        int enemyCount = _enemies.Count;

        // Build spatial grid once per tick for neighbor queries
        float separationRadius = 48f;
        _enemyGrid.Build(_enemies, separationRadius);

        float playerCenterX = _player.Center.X;
        float playerCenterY = _player.Center.Y;

        for (int i = 0; i < enemyCount; i++)
        {
            BattleEntity enemy = _enemies[i];
            if (enemy.CurrentHP <= 0)
            {
                continue;
            }
            aliveCount++;

            float enemyCenterX = enemy.Center.X;
            float enemyCenterY = enemy.Center.Y;
            float dx = playerCenterX - enemyCenterX;
            float dy = playerCenterY - enemyCenterY;
            float distSqToPlayer = dx * dx + dy * dy;
            float distToPlayer = (float)Math.Sqrt(distSqToPlayer);

            if (distToPlayer < 0.001f) distToPlayer = 0.001f;

            float dirX = dx / distToPlayer;
            float dirY = dy / distToPlayer;

            float sepX = 0f;
            float sepY = 0f;
            int neighbors = 0;
            float separationRadiusSq = separationRadius * separationRadius;

            bool doSeparation = enemyCount <= 5
                || (enemyCount <= 12 && ((i + _animCounter) % 2 == 0))
                || (enemyCount <= 20 && ((i + _animCounter) % 3 == 0))
                || ((i + _animCounter) % 5 == 0);

            if (doSeparation)
            {
                _enemyGrid.ForEachNeighborIndex(enemyCenterX, enemyCenterY, j =>
                {
                    if (i == j) return;
                    BattleEntity other = _enemies[j];
                    if (other.CurrentHP <= 0) return;

                    float odx = enemyCenterX - other.Center.X;
                    // Fast axis filter (avoids extra work/sqrt for far pairs)
                    if (Math.Abs(odx) >= separationRadius) return;

                    float ody = enemyCenterY - other.Center.Y;
                    if (Math.Abs(ody) >= separationRadius) return;

                    float distSqToOther = odx * odx + ody * ody;

                    if (distSqToOther < separationRadiusSq)
                    {
                        float distToOther = (float)Math.Sqrt(distSqToOther);
                        if (distToOther < 0.001f) distToOther = 0.001f;
                        float overlapFactor = (separationRadius - distToOther) / separationRadius;
                        sepX += odx / distToOther * overlapFactor;
                        sepY += ody / distToOther * overlapFactor;
                        neighbors++;
                    }
                });
            }

            if (neighbors > 0)
            {
                sepX /= neighbors;
                sepY /= neighbors;
            }

            float desiredRange = (enemy.AttackRange > 0) ? enemy.AttackRange : (enemy.IsRanged ? 250f : 40f);
            float moveX = dirX;
            float moveY = dirY;

            if (enemy.IsRanged)
            {
                if (enemy.DecisionCooldown > 0) enemy.DecisionCooldown--;

                if (enemy.DecisionCooldown <= 0)
                {
                    if (distToPlayer > desiredRange) enemy.AIState = 2;
                    else if (distToPlayer <= desiredRange * 0.5f) enemy.AIState = 1;
                    else enemy.AIState = 1;
                    enemy.StrafeSign = (_rnd.Next(2) == 0) ? 1 : -1;
                    enemy.DecisionCooldown = _rnd.Next(20, 40);
                }

                if (enemy.AIState == 0)
                {
                    moveX = -dirX * 0.9f + sepX;
                    moveY = -dirY * 0.9f + sepY;
                }
                else if (enemy.AIState == 1)
                {
                    moveX = -dirY * enemy.StrafeSign * 0.6f + sepX * 0.5f;
                    moveY = dirX * enemy.StrafeSign * 0.6f + sepX * 0.5f;
                }
                else
                {
                    moveX = dirX + sepX * 0.5f;
                    moveY = dirY + sepY * 0.5f;
                }
            }
            else if (distToPlayer <= desiredRange)
            {
                moveX = sepX;
                moveY = sepY;
            }
            else
            {
                moveX = dirX + sepX * 0.7f;
                moveY = dirY + sepY * 0.7f;
            }

            float mag = moveX * moveX + moveY * moveY;
            if (mag > 0.001f)
            {
                mag = (float)Math.Sqrt(mag);
                moveX /= mag;
                moveY /= mag;
            }
            else
            {
                moveX = 0f;
                moveY = 0f;
            }

            enemy.VX = Lerp(enemy.VX, moveX * enemy.Speed, 0.18f);
            enemy.VY = Lerp(enemy.VY, moveY * enemy.Speed, 0.18f);

            enemy.X += enemy.VX;
            enemy.Y += enemy.VY;

            bool isMoving = Math.Abs(enemy.VX) > 0.1f || Math.Abs(enemy.VY) > 0.1f;
            enemy.IsMoving = isMoving;
            enemy.AnimTimer += isMoving ? 0.15f : 0.05f;
            if (isMoving) enemy.FacingRight = enemy.VX > 0;

            if (enemy.VisualAttackTimer > 0) enemy.VisualAttackTimer--;

            if (enemy.IsRanged && distToPlayer <= desiredRange + 50f)
            {
                if (_rnd.NextDouble() < 0.015)
                {
                    _projectiles.Add(new SkillProjectile(enemyCenterX, enemyCenterY, playerCenterX, playerCenterY,
                        _rnd.Next(enemy.MinDamage, enemy.MaxDamage + 1), enemy: true));
                    enemy.VisualAttackTimer = 10f;
                }
            }
            else if (!enemy.IsRanged && distToPlayer <= 55f && enemy.AttackCooldown <= 0)
            {
                enemy.VisualAttackTimer = 10f;
                enemy.AttackCooldown = 45;
                ApplyDamageToPlayer(_rnd.Next(enemy.MinDamage, enemy.MaxDamage + 1));
            }

            if (enemy.AttackCooldown > 0) enemy.AttackCooldown--;

            ClampEntityPosition(enemy);
        }

        if (_enemies.Count > 0)
        {
            _enemies.RemoveAll(x => x.CurrentHP <= 0);
        }

        if (aliveCount == 0 && !_isBattleEnding)
        {
            StartBattleEndSequence(victory: true);
        }
    }

    private void UpdatePlayer()
    {
        float proposedX = _player.X;
        float proposedY = _player.Y;
        if (_w)
        {
            proposedY -= _player.Speed;
        }
        if (_s)
        {
            proposedY += _player.Speed;
        }
        if (_a)
        {
            proposedX -= _player.Speed;
        }
        if (_d)
        {
            proposedX += _player.Speed;
            _player.FacingRight = true;
        }
        else if (_a)
        {
            _player.FacingRight = false;
        }

        if (_w || _a || _s || _d)
        {
            _player.IsMoving = true;
            _player.AnimTimer += 0.2f;
        }
        else
        {
            _player.IsMoving = false;
            _player.AnimTimer += 0.05f;
        }

        if (_player.VisualAttackTimer > 0) _player.VisualAttackTimer -= 1f;

        Rectangle proposedRect = new Rectangle((int)proposedX, (int)proposedY, _player.Width, _player.Height);
        bool collides = false;
        float pushX = 0f, pushY = 0f;

        if (_isTownMode)
        {
            foreach (NpcEntity npc in _npcs)
            {
                Rectangle npcRect = new Rectangle((int)npc.X, (int)npc.Y, npc.Width, npc.Height);
                if (proposedRect.IntersectsWith(npcRect))
                {
                    collides = true;
                    break;
                }
            }
        }
        else
        {
            float playerCenterX = proposedX + _player.Width /2f;
            float playerCenterY = proposedY + _player.Height /2f;
            float minDist =20f;

            int enemyCount = _enemies.Count;
            float minDistSq = minDist * minDist;

            for (int i =0; i < enemyCount; i++)
            {
                var en = _enemies[i];
                if (en.CurrentHP <=0) continue;

                float enemyCenterX = en.X + en.Width /2f;
                float enemyCenterY = en.Y + en.Height /2f;
                float dx = playerCenterX - enemyCenterX;
                float dy = playerCenterY - enemyCenterY;
                float distSq = dx * dx + dy * dy;

                if (distSq < minDistSq && distSq >0.001f)
                {
                    float dist = (float)Math.Sqrt(distSq);
                    float overlap = minDist - dist;
                    pushX += (dx / dist) * overlap *0.5f;
                    pushY += (dy / dist) * overlap *0.5f;
                }
            }
        }

        if (!collides)
        {
            _player.X = proposedX + pushX;
            _player.Y = proposedY + pushY;
            ClampEntityPosition(_player);
        }
    }

    private void UpdateProjectiles()
    {
        for (int i = _projectiles.Count -1; i >=0; i--)
        {
            SkillProjectile proj = _projectiles[i];
            proj.Move();
            if (proj.X <0f || proj.X > (float)_arena.Width || proj.Y <0f || proj.Y > (float)_arena.Height)
            {
                _projectiles.RemoveAt(i);
            }
            else
            {
                bool hit = false;
                if (proj.IsEnemy)
                {
                    if (_player.Bounds.IntersectsWith(proj.Bounds))
                    {
                        ApplyDamageToPlayer(proj.Damage);
                        hit = true;
                    }
                }
                else
                {
                    for (int e =0; e < _enemies.Count; e++)
                    {
                        var en = _enemies[e];
                        if (en.CurrentHP >0 && proj.Bounds.IntersectsWith(en.Bounds))
                        {
                            if (proj.IsAoE)
                            {
                                for (int t =0; t < _enemies.Count; t++)
                                {
                                    var target = _enemies[t];
                                    if (target.CurrentHP <=0) continue;
                                    float dist = Distance(proj.X, proj.Y, target.Center.X, target.Center.Y);
                                    if (dist <= proj.AoERadius)
                                    {
                                        float dmgMult =1f - (dist / proj.AoERadius) *0.5f;
                                        int aoeDmg = (int)(proj.Damage * dmgMult);
                                        ApplyDamageToEnemy(target, aoeDmg, proj.IsCrit);
                                    }
                                }

                                int effectType = proj.VisualType switch
                                {
                                    1 =>12,
                                    2 =>13,
                                    _ =>14
                                };
                                Color effectColor = proj.VisualType switch
                                {
                                    1 => Color.OrangeRed,
                                    2 => Color.LightCyan,
                                    _ => Color.MediumPurple
                                };
                                _effects.Add(new VisualEffect
                                {
                                    X = proj.X,
                                    Y = proj.Y,
                                    EffectType = effectType,
                                    Size = proj.AoERadius,
                                    MaxRadius = proj.AoERadius,
                                    Color = effectColor,
                                    LifeTime =20,
                                    InitialLifeTime =20
                                });
                            }
                            else
                            {
                                ApplyDamageToEnemy(en, proj.Damage, proj.IsCrit);
                            }
                            hit = true;
                            break;
                        }
                    }
                }
                if (hit)
                {
                    _projectiles.RemoveAt(i);
                }
            }
        }
    }

    private void ApplyDamageToPlayer(int dmg)
    {
        if (_isBattleEnding)
        {
            return;
        }

        // Ensure defense (and other combat stats) are up-to-date at the moment of taking damage
        // so equipment swaps mid-fight are reflected.
        InvalidateEquipmentCache();
        RecalculatePlayerStats();

        int reduced = Math.Max(1, dmg - _player.Defense);
        _player.CurrentHP -= reduced;
        if (_player.CurrentHP <0)
        {
            _player.CurrentHP =0;
        }

        StartShake(4,1);

        _hero.HP = _player.CurrentHP;

        if (SessionManager.CurrentCharacter != null && SessionManager.CurrentCharacter.CharacterID == _hero.CharacterID)
        {
            SessionManager.CurrentCharacter = _hero;
        }

        CharacterRepository repo = new CharacterRepository();
        repo.UpdateProgress(_hero);

        this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
        if (_player.CurrentHP <=0)
        {
            StartBattleEndSequence(victory: false);
        }
    }

    private void ApplyDamageToEnemy(BattleEntity target, int dmg, bool isCrit = false)
    {
        target.CurrentHP -= dmg;

        _shakeDuration =2;
        _shakeMagnitude =1;

        Color txtColor = isCrit ? Color.Gold : Color.White;
        string txt = $"-{dmg}" + (isCrit ? "!" : "");
        int fontSize = isCrit ?14 :11;

        _effects.Add(new VisualEffect
        {
            X = target.X +10f,
            Y = target.Y,
            Text = txt,
            Color = txtColor,
            IsText = true,
            Size = fontSize,
            LifeTime = isCrit ?40 :30
        });

        _effects.Add(new VisualEffect
        {
            X = target.X + _rnd.Next(0, target.Width),
            Y = target.Y + _rnd.Next(0, target.Height),
            EffectType =1,
            Size = isCrit ?60 :40,
            Color = isCrit ? Color.OrangeRed : Color.White,
            LifeTime =10
        });

        _effects.Add(new VisualEffect
        {
            X = target.X -10,
            Y = target.Y -10,
            EffectType =2,
            Size = target.Width +20,
            Color = Color.FromArgb(150,255,255,255),
            LifeTime =3
        });

        if (target.CurrentHP <=0)
        {
            target.CurrentHP =0;
            _effects.Add(new VisualEffect
            {
                X = target.Center.X,
                Y = target.Center.Y,
                EffectType =2,
                Size =10,
                Color = Color.DarkGray,
                LifeTime =25
            });
        }
    }

    private void LoadHotbarFromSession()
    {
        if (_hero == null) return;
        List<ItemInstance> inv = _invManager.GetInventory(_hero.CharacterID);
        for (int i =0; i <5; i++)
        {
            HotbarInfo info = SessionManager.HotbarSlots[i];

            _hotbar[i].Type =0;
            _hotbar[i].ReferenceID = null;
            _hotbar[i].Item = null;
            _hotbar[i].Skill = null;
            _hotbar[i].CachedImage = null;

            if (info != null)
            {
                _hotbar[i].Type = info.Type;
                _hotbar[i].ReferenceID = info.ReferenceId;

                if (info.Type ==0)
                {
                    ItemInstance item = inv.FirstOrDefault((ItemInstance x) => x.InstanceID == info.ReferenceId);
                    _hotbar[i].Item = item;
                    _hotbar[i].CachedImage = (item != null) ? rpg_deneme.UI.ItemDrawer.DrawItem(item) : null;
                }
                else if (info.Type ==1)
                {
                    SkillManager sm = new SkillManager();
                    var skills = sm.LoadSkillsForClass((Enums.CharacterClass)_hero.Class, _hero.CharacterID);
                    _hotbar[i].Skill = skills.FirstOrDefault(s => s.SkillID == info.ReferenceId);

                    if (_hotbar[i].Skill != null)
                    {
                        Bitmap bmp = new Bitmap(40,40);
                        using (Graphics gw = Graphics.FromImage(bmp))
                        {
                            gw.Clear(Color.Transparent);
                            bool drawn = false;

                            if (!string.IsNullOrEmpty(_hotbar[i].Skill.IconPath))
                            {
                                string path = System.IO.Path.Combine(Application.StartupPath, "Assets", "Skills", _hotbar[i].Skill.IconPath + ".png");
                                if (System.IO.File.Exists(path))
                                {
                                    try
                                    {
                                        using (Image img = Image.FromFile(path))
                                        {
                                            gw.DrawImage(img,0,0,40,40);
                                            drawn = true;
                                        }
                                    }
                                    catch { }
                                }
                            }

                            if (!drawn)
                            {
                                gw.Clear(Color.DarkSlateBlue);
                                string l = (!_hotbar[i].Skill.Name.StartsWith("?")) ? _hotbar[i].Skill.Name.Substring(0,1) : "?";
                                using (Font f = new Font("Segoe UI",12, FontStyle.Bold))
                                gw.DrawString(l, f, Brushes.White,10,10);
                            }
                        }
                        _hotbar[i].CachedImage = bmp;
                    }
                }
            }
        }
    }

    private void SaveHotbarToSession()
    {
        HotbarRepository repo = new HotbarRepository();
        int charId = (_hero != null) ? _hero.CharacterID :0;

        for (int i = 0; i <5; i++)
        {
            if (_hotbar[i].ReferenceID.HasValue)
            {
                SessionManager.HotbarSlots[i] = new HotbarInfo
                {
                    Type = _hotbar[i].Type,
                    ReferenceId = _hotbar[i].ReferenceID.Value
                };
            }
            else
            {
                SessionManager.HotbarSlots[i] = null;
            }

            if (charId >0)
            {
                repo.SaveHotbar(charId, i, SessionManager.HotbarSlots[i]);
            }
        }
    }

    private void UpdateHotbarState()
    {
        LoadHotbarFromSession();
    }

    private void UseHotbarSlot(int idx)
    {
        if (idx <0 || idx >= _hotbar.Count) return;

        var slot = _hotbar[idx];

        if (slot.Type ==0)
        {
            if (slot.Item == null) return;
            ItemInstance item = slot.Item;
            if (item.RemainingCooldownSeconds >0) return;

            ConsumableManager cm = new ConsumableManager();
            if (cm.UseItem(_hero, item).Success)
            {
                _effects.Add(new VisualEffect
                {
                    X = _player.Center.X,
                    Y = _player.Center.Y,
                    EffectType =3,
                    Size =40,
                    Color = (item.EffectType == Enums.ItemEffectType.RestoreHP ? Color.Lime : Color.DeepSkyBlue),
                    LifeTime =60
                });

                if (SessionManager.CurrentCharacter != null && SessionManager.CurrentCharacter.CharacterID == _hero.CharacterID)
                {
                    SessionManager.CurrentCharacter = _hero;
                }

                this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
                SaveHotbarToSession();
                if (base.ParentForm is FormMain m)
                {
                    m.RefreshStats();
                }
            }
        }
        else if (slot.Type ==1)
        {
            if (slot.Skill == null) return;

            if (slot.Skill.RemainingCooldown >0)
            {
                NotificationManager.AddNotification($"Cooldown: {slot.Skill.RemainingCooldown:F1}s", Color.Yellow);
                return;
            }

            if (_hero.Mana < slot.Skill.ManaCost)
            {
                NotificationManager.AddNotification($"Yetersiz Mana! ({slot.Skill.ManaCost})", Color.Red);
                return;
            }

            _hero.Mana -= slot.Skill.ManaCost;
            _player.CurrentMana = _hero.Mana;

            slot.Skill.LastCastTime = DateTime.Now;

            SkillManager skillMgr = new SkillManager();

            bool skillSuccess = false;
            double effectVal = slot.Skill.GetCurrentEffectValue();

            if (slot.Skill.Name.Contains("Area") || slot.Skill.Name.Contains("Whirlwind") || slot.Skill.Name.Contains("Meteor") || slot.Skill.Name.Contains("Dönme") || slot.Skill.Name.Contains("Nova"))
            {
                int range =150;
                bool isMeteor = slot.Skill.Name.Contains("Meteor");
                bool isWhirlwind = slot.Skill.Name.Contains("Whirlwind") || slot.Skill.Name.Contains("Dönme");
                if (isMeteor) range =250;

                float aoeX = isMeteor ? _mousePos.X : _player.Center.X;
                float aoeY = isMeteor ? _mousePos.Y : _player.Center.Y;

                var equipment = GetEquipment();
                var weapon = equipment.FirstOrDefault(x => x.ItemType == Enums.ItemType.Weapon);

                foreach (var entity in _enemies.ToList())
                {
                    if (entity.CurrentHP <=0) continue;

                    double dist = Math.Sqrt(Math.Pow(entity.Center.X - aoeX,2) + Math.Pow(entity.Center.Y - aoeY,2));
                    if (dist <= range && entity.CurrentHP >0)
                    {
                        (int min, int max) dmgRange = (0,0);
                        if (_hero.Class ==3)
                            dmgRange = StatManager.CalculateMagicalDamage(_hero, weapon, _learnedSkills);
                        else
                            dmgRange = StatManager.CalculatePhysicalDamage(_hero, weapon, _learnedSkills);

                        int baseDmg = _rnd.Next(dmgRange.min, dmgRange.max +1);
                        int skillDmg = (int)effectVal;
                        int elementBonus = StatManager.CalculateElementBonus(_learnedSkills, slot.Skill.Element);
                        int finalDmg = baseDmg + skillDmg + elementBonus;

                        int critChance = StatManager.CalculateCritChance(_hero, equipment, _learnedSkills);
                        bool isCrit = _rnd.Next(100) < critChance;
                        if (isCrit) finalDmg *=2;

                        ApplyDamageToEnemy(entity, finalDmg, isCrit);
                        skillSuccess = true;
                    }
                }

                int effectType =11;
                Color effectColor = Color.Goldenrod;

                if (isMeteor || slot.Skill.Name.Contains("Fire") || slot.Skill.Name.Contains("Ateş"))
                {
                    effectType =12;
                    effectColor = Color.OrangeRed;
                }
                else if (slot.Skill.Name.Contains("Ice") || slot.Skill.Name.Contains("Buz") || slot.Skill.Name.Contains("Nova"))
                {
                    effectType =13;
                    effectColor = Color.LightCyan;
                }
                else if (slot.Skill.Name.Contains("Arcane") || slot.Skill.Name.Contains("Karanlık"))
                {
                    effectType =14;
                    effectColor = Color.MediumPurple;
                }

                _effects.Add(new VisualEffect
                {
                    X = aoeX,
                    Y = aoeY,
                    EffectType = effectType,
                    Size = range,
                    Color = effectColor,
                    LifeTime =25,
                    InitialLifeTime =25,
                    MaxRadius = range
                });
            }
            else
            {
                bool isMage = (_hero.Class ==3);

                var equipment = GetEquipment();
                var weapon = equipment.FirstOrDefault(x => x.ItemType == Enums.ItemType.Weapon);

                (int min, int max) dmgRange = (0,0);
                if (isMage)
                    dmgRange = StatManager.CalculateMagicalDamage(_hero, weapon, _learnedSkills);
                else
                    dmgRange = StatManager.CalculatePhysicalDamage(_hero, weapon, _learnedSkills);

                int baseDmg = _rnd.Next(dmgRange.min, dmgRange.max +1);
                int skillDmg = (int)effectVal;

                int elementBonus = StatManager.CalculateElementBonus(_learnedSkills, slot.Skill.Element);
                int finalDmg = baseDmg + skillDmg + elementBonus;

                int critChance = StatManager.CalculateCritChance(_hero, equipment, _learnedSkills);
                bool isCrit = _rnd.Next(100) < critChance;
                if (isCrit) finalDmg *=2;

                if (isMage)
                {
                    int vType =0;
                    switch (slot.Skill.Element)
                    {
                        case SkillElement.Fire: vType =1; break;
                        case SkillElement.Ice: vType =2; break;
                        case SkillElement.Dark: vType =3; break;
                        case SkillElement.Lightning: vType =4; break;
                        case SkillElement.Poison: vType =5; break;
                    }

                    if (slot.Skill.Name.Contains("Zincirleme") || slot.Skill.Name.Contains("Chain"))
                    {
                        var targets = _enemies.Where(e => e.CurrentHP >0)
                            .OrderBy(e => Math.Sqrt(Math.Pow(e.X - _mousePos.X,2) + Math.Pow(e.Y - _mousePos.Y,2)))
                            .Take(5)
                            .ToList();

                        float lastX = _player.Center.X, lastY = _player.Center.Y;
                        foreach (var target in targets)
                        {
                            _effects.Add(new VisualEffect
                            {
                                X = lastX,
                                Y = lastY,
                                EffectType =15,
                                TargetX = target.Center.X,
                                TargetY = target.Center.Y,
                                Color = Color.Yellow,
                                LifeTime =20,
                                InitialLifeTime =20
                            });

                            ApplyDamageToEnemy(target, finalDmg, isCrit);
                            lastX = target.Center.X;
                            lastY = target.Center.Y;
                            finalDmg = (int)(finalDmg *0.8);
                        }
                        skillSuccess = targets.Count >0;
                    }
                    else if (slot.Skill.Element == SkillElement.Fire)
                    {
                        var proj = new SkillProjectile(_player.Center.X, _player.Center.Y, _mousePos.X, _mousePos.Y, finalDmg, enemy: false, isCrit: isCrit, visualType: vType);
                        proj.IsAoE = true;
                        proj.AoERadius =60 + (slot.Skill.CurrentLevel *10);
                        _projectiles.Add(proj);
                        skillSuccess = true;
                    }
                    else
                    {
                        _projectiles.Add(new SkillProjectile(_player.Center.X, _player.Center.Y, _mousePos.X, _mousePos.Y, finalDmg, enemy: false, isCrit: isCrit, visualType: vType));
                        skillSuccess = true;
                    }
                }
                else
                {
                    bool isAoEMelee = slot.Skill.Name.Contains("Dönme") || slot.Skill.Name.Contains("Whirl") ||
                        slot.Skill.Name.Contains("Ezici") || slot.Skill.Name.Contains("Crush");

                    float range = isAoEMelee ?120f :100f;

                    float mdx = _mousePos.X - _player.Center.X;
                    float mdy = _mousePos.Y - _player.Center.Y;
                    float mDist = (float)Math.Sqrt(mdx * mdx + mdy * mdy);
                    if (mDist <1f) mDist =1f;
                    float dirX = mdx / mDist;
                    float dirY = mdy / mDist;
                    float facingAngle = (float)Math.Atan2(dirY, dirX);

                    int effectType = isAoEMelee ?11 :10;
                    Color slashColor = slot.Skill.Name.Contains("Ezici") ? Color.Red : Color.Silver;

                    _effects.Add(new VisualEffect
                    {
                        X = _player.Center.X,
                        Y = _player.Center.Y,
                        EffectType = effectType,
                        Size = (int)range,
                        Color = slashColor,
                        LifeTime =15,
                        InitialLifeTime =15,
                        Angle = facingAngle,
                        MaxRadius = (int)range
                    });

                    int hitCount =0;
                    float rangeSq = range * range;
                    for (int ei =0; ei < _enemies.Count; ei++)
                    {
                        var entity = _enemies[ei];
                        if (entity.CurrentHP <=0) continue;

                        float edx = entity.Center.X - _player.Center.X;
                        float edy = entity.Center.Y - _player.Center.Y;
                        float distSq = edx * edx + edy * edy;

                        if (distSq <= rangeSq)
                        {
                            if (isAoEMelee)
                            {
                                ApplyDamageToEnemy(entity, finalDmg, isCrit);
                                hitCount++;
                            }
                            else
                            {
                                float entityAngle = (float)Math.Atan2(edy, edx);
                                float angleDiff = Math.Abs(entityAngle - facingAngle);
                                if (angleDiff > Math.PI) angleDiff = (float)(2 * Math.PI - angleDiff);

                                if (angleDiff < Math.PI /3)
                                {
                                    ApplyDamageToEnemy(entity, finalDmg, isCrit);
                                    hitCount++;
                                }
                            }
                        }
                    }
                    skillSuccess = hitCount >0 || isAoEMelee;
                }

                if (isMage)
                {
                    string n = slot.Skill.Name;
                    int castEffectType =0;
                    Color castColor = Color.Cyan;

                    if (n.Contains("Fire") || n.Contains("Ateş") || n.Contains("Alev"))
                    {
                        castEffectType =12;
                        castColor = Color.Orange;
                    }
                    else if (n.Contains("Ice") || n.Contains("Buz") || n.Contains("Frost"))
                    {
                        castEffectType =13;
                        castColor = Color.LightCyan;
                    }
                    else if (n.Contains("Arcane") || n.Contains("Karanlık"))
                    {
                        castEffectType =14;
                        castColor = Color.MediumPurple;
                    }

                    _effects.Add(new VisualEffect
                    {
                        X = _player.Center.X,
                        Y = _player.Center.Y,
                        EffectType = castEffectType,
                        Color = castColor,
                        LifeTime =12,
                        InitialLifeTime =12,
                        Size =40
                    });
                }
            }

            CharacterRepository repo = new CharacterRepository();
            repo.UpdateProgress(_hero);
            if (base.ParentForm is FormMain m) m.UpdateBars(null);
            this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
        }
    }

    private async void StartBattleEndSequence(bool victory)
    {
        _isBattleEnding = true;
        await Task.Delay(1000);
        StopGameLoop();

        this.OnBattleEnded?.Invoke(this, victory);
    }

    public void ShowBattleResults(string message, Action onPrimary, string primaryText = "DEVAM ET", Action onSecondary = null, string secondaryText = "")
    {
        _showResults = true;
        _resultMessage = message;
        _onPrimary = onPrimary;
        _primaryBtnText = primaryText;
        _onSecondary = onSecondary;
        _secondaryBtnText = secondaryText;
        _skgl?.Invalidate();
    }

    private void UpdateTownLayout()
    {
        if (!_isTownMode)
        {
            return;
        }
        var (w, h) = GetArenaSize();
        int cx = w /2;
        int cy = h /2;

        for (int i =0; i < _npcs.Count; i++)
        {
            NpcEntity npc = _npcs[i];
            switch (npc.Type)
            {
                case Enums.NpcType.Merchant:
                    npc.X = cx -150;
                    npc.Y = cy -100;
                    break;
                case Enums.NpcType.BlackSmith:
                    npc.X = cx +100;
                    npc.Y = cy -120;
                    break;
                case Enums.NpcType.StorageKeeper:
                    npc.X = cx -140;
                    npc.Y = cy +80;
                    break;
                case Enums.NpcType.Teleporter:
                    npc.X = cx +120;
                    npc.Y = cy +80;
                    break;
                case Enums.NpcType.ArenaMaster:
                    npc.X = w -100;
                    npc.Y = cy -20;
                    break;
            }
        }

        if (_btnMap != null)
        {
            _btnMap.Location = new Point(w -180,20);
        }
    }

    private void InitTownEntities()
    {
        _npcs = new List<NpcEntity>
        {
            new NpcEntity("MARKET", Enums.NpcType.Merchant,0,0),
            new NpcEntity("IŞINLAYICI", Enums.NpcType.Teleporter,0,0),
            new NpcEntity("DEPOCU", Enums.NpcType.StorageKeeper,0,0)
            {
                Color = Color.Brown
            },
            new NpcEntity("DEMİRCİ", Enums.NpcType.BlackSmith,0,0)
            {
                Color = Color.DarkSlateGray
            },
            new NpcEntity("ARENA GUARD", Enums.NpcType.ArenaMaster,0,0)
            {
                Color = Color.Red
            }
        };
    }

    private void UpdateEffects()
    {
        for (int i = _effects.Count -1; i >=0; i--)
        {
            VisualEffect fx = _effects[i];
            fx.LifeTime--;
            if (fx.IsText)
            {
                fx.Y -=1f;
            }
            if (fx.LifeTime <=0)
            {
                _effects.RemoveAt(i);
            }
        }
    }
}
