using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using rpg_deneme.Business;
using rpg_deneme.Core;
using rpg_deneme.Models;
using rpg_deneme.Data;
using rpg_deneme.UI.Controls.GameEntities;
using SkillProjectile = rpg_deneme.UI.Controls.GameEntities.SkillProjectile;

namespace rpg_deneme.UI.Controls;

public partial class UcArena
{
    public void StartBattle(CharacterModel hero, BattleEntity enemyTemplate)
    {
        PrepareBattleCommon(hero);
        BattleEntity singleEnemy = new BattleEntity
        {
            X = base.Width - 100,
            Y = base.Height / 2 - 20,
            Width = enemyTemplate.Width,
            Height = enemyTemplate.Height,
            Speed = enemyTemplate.Speed,
            MaxHP = enemyTemplate.MaxHP,
            CurrentHP = enemyTemplate.MaxHP,
            MinDamage = enemyTemplate.MinDamage,
            MaxDamage = enemyTemplate.MaxDamage,
            Name = enemyTemplate.Name,
            IsRanged = enemyTemplate.IsRanged,
            AttackRange = enemyTemplate.AttackRange
        };
        if (_player != null)
        {
            Rectangle playerRect = new Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height);
            Rectangle enemyRect = new Rectangle((int)singleEnemy.X, (int)singleEnemy.Y, singleEnemy.Width, singleEnemy.Height);
            int tries = 0;
            Random rnd = new Random();
            while (enemyRect.IntersectsWith(playerRect) && tries < 20)
            {
                singleEnemy.X = base.Width - 100 - rnd.Next(0, 200);
                singleEnemy.Y = 100 + rnd.Next(0, Math.Max(100, base.Height - 200));
                enemyRect = new Rectangle((int)singleEnemy.X, (int)singleEnemy.Y, singleEnemy.Width, singleEnemy.Height);
                tries++;
            }
        }
        _enemies.Add(singleEnemy);
        StartGameLoop();
    }

    public void StartSurvivalBattle(CharacterModel hero, List<EnemyModel> enemyTemplates)
    {
        PrepareBattleCommon(hero);
        (int, int) arenaSize = GetArenaSize();
        int w = arenaSize.Item1;
        int h = arenaSize.Item2;
        Random rnd = new Random();
        foreach (EnemyModel tmpl in enemyTemplates)
        {
            int ex = w - 100 - rnd.Next(0, 200);
            int ey = 100 + rnd.Next(0, Math.Max(100, h - 200));
            bool isRangedUnit = tmpl.IsRanged || tmpl.Type == Enums.EnemyType.Ranged;
            int attackRange = ((tmpl.AttackRange > 0) ? tmpl.AttackRange : (isRangedUnit ? 250 : 50));
            BattleEntity newEnemy = new BattleEntity
            {
                X = ex,
                Y = ey,
                Width = tmpl.Width,
                Height = tmpl.Height,
                Speed = tmpl.Speed,
                MaxHP = tmpl.MaxHP,
                CurrentHP = tmpl.MaxHP,
                MinDamage = tmpl.MinDamage,
                MaxDamage = tmpl.MaxDamage,
                Name = tmpl.Name,
                IsRanged = isRangedUnit,
                AttackRange = attackRange
            };
            if (_player != null)
            {
                Rectangle playerRect = new Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height);
                Rectangle eRect = new Rectangle((int)newEnemy.X, (int)newEnemy.Y, newEnemy.Width, newEnemy.Height);
                int tries = 0;
                while ((eRect.IntersectsWith(playerRect) || _enemies.Any((BattleEntity en) => en.Bounds.IntersectsWith(eRect))) && tries < 30)
                {
                    ex = w - 100 - rnd.Next(0, 300);
                    ey = 80 + rnd.Next(0, Math.Max(100, h - 160));
                    newEnemy.X = ex;
                    newEnemy.Y = ey;
                    eRect = new Rectangle((int)newEnemy.X, (int)newEnemy.Y, newEnemy.Width, newEnemy.Height);
                    tries++;
                }
            }
            _enemies.Add(newEnemy);
        }
        StartGameLoop();
    }

    public void StartTown(CharacterModel hero)
    {
        _isBattleEnding = false;
        _hero = hero;
        LoadHotbarFromSession();
        _isTownMode = true;
        _projectiles.Clear();
        _enemies.Clear();
        _w = (_a = (_s = (_d = false)));
        InitTownEntities();
        UpdateTownLayout();
        (int, int) arenaSize = GetArenaSize();
        int w = arenaSize.Item1;
        int h = arenaSize.Item2;

        List<ItemInstance> inventory = _invManager.GetInventory(_hero.CharacterID);
        List<ItemInstance> equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
        int maxHp = StatManager.CalculateTotalMaxHP(_hero, equippedItems);

        int currentHP = _hero.HP;
        if (currentHP > maxHp) currentHP = maxHp;
        if (currentHP < 0) currentHP = 0;

        _player = new BattleEntity
        {
            X = w / 2 - 16,
            Y = h / 2 - 16,
            Width = 32,
            Height = 32,
            Speed = 5f,
            MaxHP = maxHp,
            CurrentHP = currentHP,
            MinDamage = 0,
            MaxDamage = 0,
            Defense = 0
        };

        _hero.HP = currentHP;
        StartGameLoop();
    }

    private void PrepareBattleCommon(CharacterModel hero)
    {
        _hero = hero;
        LoadHotbarFromSession();
        _projectiles.Clear();
        _enemies.Clear();
        _w = (_a = (_s = (_d = false)));
        _isBattleEnding = false;
        _isTownMode = false;

        List<ItemInstance> inventory = _invManager.GetInventory(_hero.CharacterID);
        List<ItemInstance> equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
        int maxHp = StatManager.CalculateTotalMaxHP(_hero, equippedItems);

        int currentHP = _hero.HP;

        if (currentHP > maxHp)
        {
            currentHP = maxHp;
        }
        if (currentHP < 0)
        {
            currentHP = 0;
        }

        (int, int) arenaSize = GetArenaSize();
        int arenaW = arenaSize.Item1;
        int arenaH = arenaSize.Item2;
        int startX = Math.Max(0, arenaW / 2 - 16);
        int startY = Math.Max(0, arenaH / 2 - 16);
        _player = new BattleEntity
        {
            X = startX,
            Y = startY,
            Width = 32,
            Height = 32,
            Speed = 5f,
            MaxHP = maxHp,
            CurrentHP = currentHP,
            MinDamage = 0,
            MaxDamage = 0,
            Defense = 0
        };

        _hero.HP = currentHP;
        RecalculatePlayerStats();

        if (_player.CurrentHP > _player.MaxHP)
        {
            _player.CurrentHP = _player.MaxHP;
            _hero.HP = _player.MaxHP;
        }
    }

    // Stats refresh (equipment changes during battle)
    private long _lastStatsRefreshTicks;
    private static readonly long StatsRefreshIntervalTicks = Stopwatch.Frequency * 2; // 2 seconds

    // Cached skills - avoid DB query every frame
    private List<SkillModel> _cachedLearnedSkills;
 private long _lastSkillFetchTicks;

    public void RecalculatePlayerStats()
    {
  if (_hero == null || _player == null) return;

     // Use cached skills - only refresh every 10 seconds (doubled from 5)
   long nowTicks = _cacheWatch.ElapsedTicks;
     if (_cachedLearnedSkills == null || (nowTicks - _lastSkillFetchTicks) > Stopwatch.Frequency * 10)
 {
        SkillManager skillMgr = new SkillManager();
    _cachedLearnedSkills = skillMgr.LoadSkillsForClass((Enums.CharacterClass)_hero.Class, _hero.CharacterID);
        _lastSkillFetchTicks = nowTicks;
 }
   _learnedSkills = _cachedLearnedSkills;

   // Update hotbar skill references (without DB query) - only update cooldowns
 foreach (var slot in _hotbar)
   {
 if (slot.Type == 1 && slot.Skill != null)
        {
     var freshSkill = _learnedSkills.FirstOrDefault(s => s.SkillID == slot.Skill.SkillID);
    if (freshSkill != null)
   {
        // Only preserve LastCastTime, everything else from cache
       freshSkill.LastCastTime = slot.Skill.LastCastTime;
       slot.Skill = freshSkill;
  }
  }
     }

     // Use cached equipment
   var equipment = GetEquipment();
   ItemInstance equippedWeapon = null;
  for (int i = 0; i < equipment.Count; i++)
      {
        if (equipment[i].ItemType == Enums.ItemType.Weapon && equipment[i].Location == Enums.ItemLocation.Equipment)
 {
       equippedWeapon = equipment[i];
     break;
        }
 }

        _currentWeaponUpgradeLevel = equippedWeapon?.UpgradeLevel ?? 0;
   _currentWeaponGrade = equippedWeapon?.Grade ?? Enums.ItemGrade.Common;

   var (minDmg, maxDmg) = (_hero.Class == 3)
      ? StatManager.CalculateMagicalDamage(_hero, equippedWeapon, _learnedSkills)
     : StatManager.CalculatePhysicalDamage(_hero, equippedWeapon, _learnedSkills);

 int calculatedDefense = StatManager.CalculateTotalDefense(_hero, equipment, _learnedSkills);

      _attackDelayMs = StatManager.CalculateAttackDelay(_hero, equipment, _learnedSkills);
   _manaCostPerHit = StatManager.CalculateAttackManaCost(_hero);
     _player.MinDamage = minDmg;
    _player.MaxDamage = maxDmg;
        _player.Defense = calculatedDefense;

        int moveSpeedBonus = StatManager.CalculateMovementSpeedBonus(_learnedSkills);
  _player.Speed = 5f + moveSpeedBonus * 0.1f;

   _manaRegenAmount = StatManager.GetTotalAttributeValue(equipment, Enums.ItemAttributeType.ManaRegen);

      var passiveBonus = StatManager.CalculatePassiveBonuses(_learnedSkills);
        _manaRegenAmount += (int)passiveBonus.ManaRegenBonus;

        NotificationManager.ClearBuffs();
      if (_manaRegenAmount > 0) NotificationManager.AddBuff($"Mana Regen: {_manaRegenAmount}/3sn", "ManaRegen", _manaRegenAmount);

        int newMaxHP = StatManager.CalculateTotalMaxHP(_hero, equipment, _learnedSkills);
     int oldMaxHP = _player.MaxHP;
  _player.MaxHP = newMaxHP;
        if (oldMaxHP > 0 && newMaxHP != oldMaxHP && _player.CurrentHP > newMaxHP)
        {
            _player.CurrentHP = newMaxHP;
   _hero.HP = newMaxHP;
  }
   if (_player.CurrentHP > _player.MaxHP)
    {
 _player.CurrentHP = _player.MaxHP;
        _hero.HP = _player.MaxHP;
   }

     int newMaxMana = StatManager.CalculateTotalMaxMana(_hero, equipment, _learnedSkills);
    _player.MaxMana = newMaxMana;
        if (_hero.Mana > newMaxMana) _hero.Mana = newMaxMana;
  _player.CurrentMana = _hero.Mana;
    }

    private void StartGameLoop()
    {
        if (_loopRunning) return;

        _loopRunning = true;

        // Use simple Timer instead of Application.Idle
        if (_gameLoop == null)
        {
     _gameLoop = new System.Windows.Forms.Timer();
         _gameLoop.Interval = 16; // ~60fps
          _gameLoop.Tick += GameLoop_Tick;
        }
     _gameLoop.Start();

        Focus();
    }

    private void StopGameLoop()
    {
        if (!_loopRunning) return;
        _loopRunning = false;
        _gameLoop?.Stop();
    }

    private void GameLoop_Tick(object? sender, EventArgs e)
    {
        if (!_loopRunning) return;

        // Single simulation step per tick
        StepSimulation();

        // Request redraw
    _skgl?.Invalidate();
    }

    // One fixed-step simulation tick (60Hz)
    private void StepSimulation()
    {
     Fps_OnGameTick();

 if (_player == null) return;

    if (_isBattleEnding)
     {
        UpdateEffects();
      return;
      }

   // Keep hero<->player resources in sync
     if (_hero != null)
        {
     _animCounter++;
 
   // Periodically refresh stats - every 240 ticks (~4 seconds instead of 2)
     if (_animCounter % 240 == 0)
     {
   InvalidateEquipmentCache();
    RecalculatePlayerStats();

        if (_hero.HP > _player.MaxHP) _hero.HP = _player.MaxHP;
     if (_hero.Mana > _player.MaxMana) _hero.Mana = _player.MaxMana;
  }

          // Deferred DB save - every 5 seconds if needed
        if (_pendingHeroSave)
   {
 _saveTimer++;
         if (_saveTimer >= 300) // 5 seconds at 60fps
    {
   _saveTimer = 0;
  _pendingHeroSave = false;
             // Save in background to not block game loop
    var heroToSave = _hero;
         Task.Run(() => {
   try {
 var repo = new CharacterRepository();
        repo.UpdateProgress(heroToSave);
  } catch { }
});
    }
  }

        if (_hero.HP != _player.CurrentHP)
{
          _player.CurrentHP = _hero.HP;
        }

       if (_player.CurrentHP > _player.MaxHP)
            {
         _player.CurrentHP = _player.MaxHP;
  _hero.HP = _player.MaxHP;
   }

  if (_hero.Mana != _player.CurrentMana)
    {
            _player.CurrentMana = _hero.Mana;
  }

      if (_player.CurrentMana > _player.MaxMana)
     {
      _player.CurrentMana = _player.MaxMana;
   _hero.Mana = _player.CurrentMana;
  }

   // Mana regen - every 3 seconds (180 ticks)
    _manaRegenTimer++;
      if (_manaRegenTimer >= 180)
          {
      _manaRegenTimer = 0;
       if (_manaRegenAmount > 0 && _player.CurrentMana < _player.MaxMana)
     {
        _player.CurrentMana += _manaRegenAmount;
        if (_player.CurrentMana > _player.MaxMana) _player.CurrentMana = _player.MaxMana;
         _hero.Mana = _player.CurrentMana;
 this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
}
        }
     }

  if (_shakeDuration > 0)
        {
      _shakeDuration--;
   }

        if (_animCounter > 10000) _animCounter = 0;

   // Update notifications every 3 ticks instead of every tick
        if (_animCounter % 3 == 0)
        {
            NotificationManager.Update();
        }

        UpdatePlayer();
        UpdateProjectiles();
   UpdateEffects();
     if (!_isTownMode)
        {
        UpdateEnemies();
   }
  }

    private void UpdateEnemies()
    {
        if (_enemyAttackCooldown > 0)
   {
    _enemyAttackCooldown--;
        }

        int aliveCount = 0;
        int enemyCount = _enemies.Count;

        // Build spatial grid once per tick for neighbor queries
        float separationRadius = 48f;
        _enemyGrid.Build(_enemies, separationRadius);

        float playerCenterX = _player.Center.X;
    float playerCenterY = _player.Center.Y;

        for (int i = 0; i < enemyCount; i++)
        {
            BattleEntity enemy = _enemies[i];
    if (enemy.CurrentHP <= 0)
      {
         continue;
            }
        aliveCount++;

   float enemyCenterX = enemy.Center.X;
      float enemyCenterY = enemy.Center.Y;
            float dx = playerCenterX - enemyCenterX;
            float dy = playerCenterY - enemyCenterY;
    float distSqToPlayer = dx * dx + dy * dy;
            float distToPlayer = (float)Math.Sqrt(distSqToPlayer);

            if (distToPlayer < 0.001f) distToPlayer = 0.001f;

  float dirX = dx / distToPlayer;
            float dirY = dy / distToPlayer;

          float sepX = 0f;
       float sepY = 0f;
     int neighbors = 0;
            float separationRadiusSq = separationRadius * separationRadius;

            bool doSeparation = enemyCount <= 5
            || (enemyCount <= 12 && ((i + _animCounter) % 2 == 0))
       || (enemyCount <= 20 && ((i + _animCounter) % 3 == 0))
           || ((i + _animCounter) % 5 == 0);

       if (doSeparation)
     {
      _enemyGrid.ForEachNeighborIndex(enemyCenterX, enemyCenterY, j =>
     {
     if (i == j) return;
        BattleEntity other = _enemies[j];
         if (other.CurrentHP <= 0) return;

        float odx = enemyCenterX - other.Center.X;
   // Fast axis filter (avoids extra work/sqrt for far pairs)
if (Math.Abs(odx) >= separationRadius) return;

   float ody = enemyCenterY - other.Center.Y;
   if (Math.Abs(ody) >= separationRadius) return;

  float distSqToOther = odx * odx + ody * ody;

      if (distSqToOther < separationRadiusSq)
        {
       float distToOther = (float)Math.Sqrt(distSqToOther);
           if (distToOther < 0.001f) distToOther = 0.001f;
        float overlapFactor = (separationRadius - distToOther) / separationRadius;
           sepX += odx / distToOther * overlapFactor;
        sepY += ody / distToOther * overlapFactor;
    neighbors++;
          }
    });
    }

            if (neighbors > 0)
   {
                sepX /= neighbors;
                sepY /= neighbors;
}

          float desiredRange = (enemy.AttackRange > 0) ? enemy.AttackRange : (enemy.IsRanged ? 250f : 40f);
    float moveX = dirX;
   float moveY = dirY;

        if (enemy.IsRanged)
            {
 if (enemy.DecisionCooldown > 0) enemy.DecisionCooldown--;

         if (enemy.DecisionCooldown <= 0)
   {
        if (distToPlayer > desiredRange) enemy.AIState = 2;
       else if (distToPlayer <= desiredRange * 0.5f) enemy.AIState = 0;
      else enemy.AIState = 1;
        enemy.StrafeSign = (_rnd.Next(2) == 0) ? 1 : -1;
 enemy.DecisionCooldown = _rnd.Next(20, 40);
     }

 if (enemy.AIState == 0)
       {
          moveX = -dirX * 0.9f + sepX;
              moveY = -dirY * 0.9f + sepY;
     }
 else if (enemy.AIState == 1)
     {
 moveX = -dirY * enemy.StrafeSign * 0.6f + sepX * 0.5f;
      moveY = dirX * enemy.StrafeSign * 0.6f + sepY * 0.5f;
                }
                else
          {
            moveX = dirX + sepX * 0.5f;
  moveY = dirY + sepY * 0.5f;
                }
        }
  else if (distToPlayer <= desiredRange)
         {
          moveX = sepX;
      moveY = sepY;
            }
else
      {
         moveX = dirX + sepX * 0.7f;
     moveY = dirY + sepY * 0.7f;
     }

         float mag = moveX * moveX + moveY * moveY;
            if (mag > 0.001f)
  {
          mag = (float)Math.Sqrt(mag);
    moveX /= mag;
                moveY /= mag;
   }
        else
            {
      moveX = 0f;
            moveY = 0f;
         }

     enemy.VX = Lerp(enemy.VX, moveX * enemy.Speed, 0.18f);
    enemy.VY = Lerp(enemy.VY, moveY * enemy.Speed, 0.18f);

  enemy.X += enemy.VX;
            enemy.Y += enemy.VY;

            bool isMoving = Math.Abs(enemy.VX) > 0.1f || Math.Abs(enemy.VY) > 0.1f;
            enemy.IsMoving = isMoving;
        enemy.AnimTimer += isMoving ? 0.15f : 0.05f;
      if (isMoving) enemy.FacingRight = enemy.VX > 0;

         if (enemy.VisualAttackTimer > 0) enemy.VisualAttackTimer--;

if (enemy.IsRanged && distToPlayer <= desiredRange + 50f)
       {
           if (_rnd.NextDouble() < 0.015)
       {
          _projectiles.Add(new SkillProjectile(enemyCenterX, enemyCenterY, playerCenterX, playerCenterY,
      _rnd.Next(enemy.MinDamage, enemy.MaxDamage + 1), enemy: true));
          enemy.VisualAttackTimer = 10f;
                }
            }
            else if (!enemy.IsRanged && distToPlayer <= 55f && enemy.AttackCooldown <= 0)
            {
    enemy.VisualAttackTimer = 10f;
     enemy.AttackCooldown = 45;
    ApplyDamageToPlayer(_rnd.Next(enemy.MinDamage, enemy.MaxDamage + 1));
  }

     if (enemy.AttackCooldown > 0) enemy.AttackCooldown--;

          ClampEntityPosition(enemy);
        }

        if (_enemies.Count > 0)
        {
       _enemies.RemoveAll(x => x.CurrentHP <= 0);
  }

        if (aliveCount == 0 && !_isBattleEnding)
        {
            StartBattleEndSequence(victory: true);
        }
    }

    private void UpdatePlayer()
    {
        float proposedX = _player.X;
        float proposedY = _player.Y;
        if (_w)
        {
            proposedY -= _player.Speed;
        }
        if (_s)
        {
            proposedY += _player.Speed;
        }
        if (_a)
        {
            proposedX -= _player.Speed;
        }
        if (_d)
        {
            proposedX += _player.Speed;
            _player.FacingRight = true;
        }
        else if (_a)
        {
            _player.FacingRight = false;
        }

        if (_w || _a || _s || _d)
        {
            _player.IsMoving = true;
            _player.AnimTimer += 0.2f;
        }
        else
        {
            _player.IsMoving = false;
            _player.AnimTimer += 0.05f;
        }

        if (_player.VisualAttackTimer > 0) _player.VisualAttackTimer -= 1f;

        Rectangle proposedRect = new Rectangle((int)proposedX, (int)proposedY, _player.Width, _player.Height);
        bool collides = false;
        float pushX = 0f, pushY = 0f;

        if (_isTownMode)
        {
            foreach (NpcEntity npc in _npcs)
            {
                Rectangle npcRect = new Rectangle((int)npc.X, (int)npc.Y, npc.Width, npc.Height);
                if (proposedRect.IntersectsWith(npcRect))
                {
                    collides = true;
                    break;
                }
            }
        }
        else
        {
            float playerCenterX = proposedX + _player.Width /2f;
            float playerCenterY = proposedY + _player.Height /2f;
            float minDist =20f;

            int enemyCount = _enemies.Count;
            float minDistSq = minDist * minDist;

            for (int i =0; i < enemyCount; i++)
            {
                var en = _enemies[i];
                if (en.CurrentHP <=0) continue;

                float enemyCenterX = en.X + en.Width /2f;
                float enemyCenterY = en.Y + en.Height /2f;
                float dx = playerCenterX - enemyCenterX;
                float dy = playerCenterY - enemyCenterY;
                float distSq = dx * dx + dy * dy;

                if (distSq < minDistSq && distSq >0.001f)
                {
                    float dist = (float)Math.Sqrt(distSq);
                    float overlap = minDist - dist;
                    pushX += (dx / dist) * overlap *0.5f;
                    pushY += (dy / dist) * overlap *0.5f;
                }
            }
        }

        if (!collides)
        {
            _player.X = proposedX + pushX;
            _player.Y = proposedY + pushY;
            ClampEntityPosition(_player);
        }
    }

    private void UpdateProjectiles()
    {
    // Use forward iteration with index tracking for safe removal
     int writeIndex = 0;
 int projCount = _projectiles.Count;
  
   var (arenaW, arenaH) = GetArenaSize();
  
        for (int i = 0; i < projCount; i++)
        {
     SkillProjectile proj = _projectiles[i];
     proj.Move();
  
    bool shouldRemove = false;
     
      // Bounds check
    if (proj.X < -20f || proj.X > arenaW + 20f || proj.Y < -20f || proj.Y > arenaH + 20f)
       {
       shouldRemove = true;
    }
       else
     {
     bool hit = false;
   if (proj.IsEnemy)
     {
     // Use pre-computed bounds
     var projBounds = proj.Bounds;
        if (_player.Bounds.IntersectsWith(projBounds))
       {
             ApplyDamageToPlayer(proj.Damage);
          hit = true;
       }
    }
         else
    {
    var projBounds = proj.Bounds;
          int enemyCount = _enemies.Count;
        
       for (int e = 0; e < enemyCount; e++)
       {
var en = _enemies[e];
       if (en.CurrentHP <= 0) continue;
  
             if (projBounds.IntersectsWith(en.Bounds))
           {
         if (proj.IsAoE)
           {
  float projCx = proj.X;
  float projCy = proj.Y;
 float aoeSq = proj.AoERadius * proj.AoERadius;
        
        // Only check living enemies
       for (int t = 0; t < enemyCount; t++)
    {
       var target = _enemies[t];
        if (target.CurrentHP <= 0) continue;
        
      float dx = target.Center.X - projCx;
     float dy = target.Center.Y - projCy;
    float distSq = dx * dx + dy * dy;
 
    if (distSq <= aoeSq)
     {
        float dist = MathF.Sqrt(distSq);
         float dmgMult = 1f - (dist / proj.AoERadius) * 0.5f;
        int aoeDmg = (int)(proj.Damage * dmgMult);
      ApplyDamageToEnemy(target, aoeDmg, proj.IsCrit);
        }
       }

     // Only add effect if under limit
        if (_effects.Count < 50)
              {
       int effectType = proj.VisualType switch
        {
         1 => 12,
      2 => 13,
         _ => 14
       };
  Color effectColor = proj.VisualType switch
       {
          1 => Color.OrangeRed,
      2 => Color.LightCyan,
        _ => Color.MediumPurple
    };
       _effects.Add(new VisualEffect
        {
       X = proj.X,
           Y = proj.Y,
         EffectType = effectType,
       Size = proj.AoERadius,
         MaxRadius = proj.AoERadius,
         Color = effectColor,
      LifeTime = 20,
           InitialLifeTime = 20
});
      }
       }
       else
      {
         ApplyDamageToEnemy(en, proj.Damage, proj.IsCrit);
        }
  hit = true;
     break;
         }
     }
       }
     
  if (hit)
  {
       shouldRemove = true;
        }
   }
     
  // Keep alive projectiles
  if (!shouldRemove)
            {
    if (writeIndex != i)
   {
           _projectiles[writeIndex] = proj;
      }
  writeIndex++;
            }
        }
        
        // Batch remove dead projectiles
  if (writeIndex < projCount)
        {
       _projectiles.RemoveRange(writeIndex, projCount - writeIndex);
   }
    }

    private void ApplyDamageToPlayer(int dmg)
    {
  if (_isBattleEnding)
        {
            return;
        }

        // DON'T recalculate stats on every hit - too expensive!
        // Stats are refreshed periodically in StepSimulation already.

        int reduced = Math.Max(1, dmg - _player.Defense);
   _player.CurrentHP -= reduced;
 if (_player.CurrentHP < 0)
{
            _player.CurrentHP = 0;
        }

        StartShake(4, 1);

        _hero.HP = _player.CurrentHP;

        if (SessionManager.CurrentCharacter != null && SessionManager.CurrentCharacter.CharacterID == _hero.CharacterID)
        {
  SessionManager.CurrentCharacter = _hero;
        }

        // Don't save to DB on every hit - defer to battle end or periodic save
        _pendingHeroSave = true;

        this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
        if (_player.CurrentHP <= 0)
        {
            StartBattleEndSequence(victory: false);
   }
    }

    // Flag for deferred DB save
    private bool _pendingHeroSave = false;
    private int _saveTimer = 0;

    private void ApplyDamageToEnemy(BattleEntity target, int dmg, bool isCrit = false)
    {
        target.CurrentHP -= dmg;

 _shakeDuration = 2;
        _shakeMagnitude = 1;

        // Limit effects to reduce rendering load
        if (_effects.Count < 50)
        {
    Color txtColor = isCrit ? Color.Gold : Color.White;
     string txt = $"-{dmg}" + (isCrit ? "!" : "");
    int fontSize = isCrit ? 14 : 11;

            _effects.Add(new VisualEffect
            {
             X = target.X + 10f,
   Y = target.Y,
       Text = txt,
      Color = txtColor,
   IsText = true,
          Size = fontSize,
       LifeTime = isCrit ? 40 : 30
            });

      // Only add hit effect, skip the other two for performance
   _effects.Add(new VisualEffect
            {
    X = target.X + _rnd.Next(0, target.Width),
       Y = target.Y + _rnd.Next(0, target.Height),
    EffectType = 1,
 Size = isCrit ? 60 : 40,
              Color = isCrit ? Color.OrangeRed : Color.White,
           LifeTime = 10
  });
        }

 if (target.CurrentHP <= 0)
        {
     target.CurrentHP = 0;
    if (_effects.Count < 50)
{
             _effects.Add(new VisualEffect
   {
       X = target.Center.X,
       Y = target.Center.Y,
        EffectType = 2,
        Size = 10,
     Color = Color.DarkGray,
    LifeTime = 25
         });
            }
        }
    }

    private void LoadHotbarFromSession()
    {
        if (_hero == null) return;
        List<ItemInstance> inv = _invManager.GetInventory(_hero.CharacterID);
        for (int i =0; i <5; i++)
        {
            HotbarInfo info = SessionManager.HotbarSlots[i];

            _hotbar[i].Type =0;
            _hotbar[i].ReferenceID = null;
            _hotbar[i].Item = null;
            _hotbar[i].Skill = null;
            _hotbar[i].CachedImage = null;

            if (info != null)
            {
                _hotbar[i].Type = info.Type;
                _hotbar[i].ReferenceID = info.ReferenceId;

                if (info.Type ==0)
                {
                    ItemInstance item = inv.FirstOrDefault((ItemInstance x) => x.InstanceID == info.ReferenceId);
                    _hotbar[i].Item = item;
                    _hotbar[i].CachedImage = (item != null) ? rpg_deneme.UI.ItemDrawer.DrawItem(item) : null;
                }
                else if (info.Type ==1)
                {
                    SkillManager sm = new SkillManager();
                    var skills = sm.LoadSkillsForClass((Enums.CharacterClass)_hero.Class, _hero.CharacterID);
                    _hotbar[i].Skill = skills.FirstOrDefault(s => s.SkillID == info.ReferenceId);

                    if (_hotbar[i].Skill != null)
                    {
                        Bitmap bmp = new Bitmap(40,40);
                        using (Graphics gw = Graphics.FromImage(bmp))
                        {
                            gw.Clear(Color.Transparent);
                            bool drawn = false;

                            if (!string.IsNullOrEmpty(_hotbar[i].Skill.IconPath))
                            {
                                string path = System.IO.Path.Combine(Application.StartupPath, "Assets", "Skills", _hotbar[i].Skill.IconPath + ".png");
                                if (System.IO.File.Exists(path))
                                {
                                    try
                                    {
                                        using (Image img = Image.FromFile(path))
                                        {
                                            gw.DrawImage(img,0,0,40,40);
                                            drawn = true;
                                        }
                                    }
                                    catch { }
                                }
                            }

                            if (!drawn)
                            {
                                gw.Clear(Color.DarkSlateBlue);
                                string l = (!_hotbar[i].Skill.Name.StartsWith("?")) ? _hotbar[i].Skill.Name.Substring(0,1) : "?";
                                using (Font f = new Font("Segoe UI",12, FontStyle.Bold))
                                gw.DrawString(l, f, Brushes.White,10,10);
                            }
                        }
                        _hotbar[i].CachedImage = bmp;
                    }
                }
            }
        }
    }

    private void SaveHotbarToSession()
    {
        HotbarRepository repo = new HotbarRepository();
        int charId = (_hero != null) ? _hero.CharacterID :0;

        for (int i = 0; i <5; i++)
        {
            if (_hotbar[i].ReferenceID.HasValue)
            {
                SessionManager.HotbarSlots[i] = new HotbarInfo
                {
                    Type = _hotbar[i].Type,
                    ReferenceId = _hotbar[i].ReferenceID.Value
                };
            }
            else
            {
                SessionManager.HotbarSlots[i] = null;
            }

            if (charId >0)
            {
                repo.SaveHotbar(charId, i, SessionManager.HotbarSlots[i]);
            }
        }
    }

    private void UpdateHotbarState()
    {
        LoadHotbarFromSession();
    }

    private void UseHotbarSlot(int idx)
    {
        if (idx <0 || idx >= _hotbar.Count) return;

        var slot = _hotbar[idx];

        if (slot.Type ==0)
        {
            if (slot.Item == null) return;
            ItemInstance item = slot.Item;
            if (item.RemainingCooldownSeconds >0) return;

            ConsumableManager cm = new ConsumableManager();
            if (cm.UseItem(_hero, item).Success)
            {
                _effects.Add(new VisualEffect
                {
                    X = _player.Center.X,
                    Y = _player.Center.Y,
                    EffectType =3,
                    Size =40,
                    Color = (item.EffectType == Enums.ItemEffectType.RestoreHP ? Color.Lime : Color.DeepSkyBlue),
                    LifeTime =60
                });

                if (SessionManager.CurrentCharacter != null && SessionManager.CurrentCharacter.CharacterID == _hero.CharacterID)
                {
                    SessionManager.CurrentCharacter = _hero;
                }

                this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
                SaveHotbarToSession();
                if (base.ParentForm is FormMain m)
                {
                    m.RefreshStats();
                }
            }
        }
        else if (slot.Type ==1)
        {
            if (slot.Skill == null) return;

            if (slot.Skill.RemainingCooldown >0)
            {
                NotificationManager.AddNotification($"Cooldown: {slot.Skill.RemainingCooldown:F1}s", Color.Yellow);
                return;
            }

            if (_hero.Mana < slot.Skill.ManaCost)
            {
                NotificationManager.AddNotification($"Yetersiz Mana! ({slot.Skill.ManaCost})", Color.Red);
                return;
            }

            _hero.Mana -= slot.Skill.ManaCost;
            _player.CurrentMana = _hero.Mana;

            slot.Skill.LastCastTime = DateTime.Now;

            SkillManager skillMgr = new SkillManager();

            bool skillSuccess = false;
            double effectVal = slot.Skill.GetCurrentEffectValue();

            if (slot.Skill.Name.Contains("Area") || slot.Skill.Name.Contains("Whirlwind") || slot.Skill.Name.Contains("Meteor") || slot.Skill.Name.Contains("Dönme") || slot.Skill.Name.Contains("Nova"))
            {
                int range =150;
                bool isMeteor = slot.Skill.Name.Contains("Meteor");
                bool isWhirlwind = slot.Skill.Name.Contains("Whirlwind") || slot.Skill.Name.Contains("Dönme");
                if (isMeteor) range =250;

                float aoeX = isMeteor ? _mousePos.X : _player.Center.X;
                float aoeY = isMeteor ? _mousePos.Y : _player.Center.Y;

                var equipment = GetEquipment();
                var weapon = equipment.FirstOrDefault(x => x.ItemType == Enums.ItemType.Weapon);

                foreach (var entity in _enemies.ToList())
                {
                    if (entity.CurrentHP <=0) continue;

                    double dist = Math.Sqrt(Math.Pow(entity.Center.X - aoeX,2) + Math.Pow(entity.Center.Y - aoeY,2));
                    if (dist <= range && entity.CurrentHP >0)
                    {
                        (int min, int max) dmgRange = (0,0);
                        if (_hero.Class ==3)
                            dmgRange = StatManager.CalculateMagicalDamage(_hero, weapon, _learnedSkills);
                        else
                            dmgRange = StatManager.CalculatePhysicalDamage(_hero, weapon, _learnedSkills);

                        int baseDmg = _rnd.Next(dmgRange.min, dmgRange.max +1);
                        int skillDmg = (int)effectVal;
                        int elementBonus = StatManager.CalculateElementBonus(_learnedSkills, slot.Skill.Element);
                        int finalDmg = baseDmg + skillDmg + elementBonus;

                        int critChance = StatManager.CalculateCritChance(_hero, equipment, _learnedSkills);
                        bool isCrit = _rnd.Next(100) < critChance;
                        if (isCrit) finalDmg *=2;

                        ApplyDamageToEnemy(entity, finalDmg, isCrit);
                        skillSuccess = true;
                    }
                }

                int effectType =11;
                Color effectColor = Color.Goldenrod;

                if (isMeteor || slot.Skill.Name.Contains("Fire") || slot.Skill.Name.Contains("Ateş"))
                {
                    effectType =12;
                    effectColor = Color.OrangeRed;
                }
                else if (slot.Skill.Name.Contains("Ice") || slot.Skill.Name.Contains("Buz") || slot.Skill.Name.Contains("Nova"))
                {
                    effectType =13;
                    effectColor = Color.LightCyan;
                }
                else if (slot.Skill.Name.Contains("Arcane") || slot.Skill.Name.Contains("Karanlık"))
                {
                    effectType =14;
                    effectColor = Color.MediumPurple;
                }

                _effects.Add(new VisualEffect
                {
                    X = aoeX,
                    Y = aoeY,
                    EffectType = effectType,
                    Size = range,
                    Color = effectColor,
                    LifeTime =25,
                    InitialLifeTime =25,
                    MaxRadius = range
                });
            }
            else
            {
                bool isMage = (_hero.Class ==3);

                var equipment = GetEquipment();
                var weapon = equipment.FirstOrDefault(x => x.ItemType == Enums.ItemType.Weapon);

                (int min, int max) dmgRange = (0,0);
                if (isMage)
                    dmgRange = StatManager.CalculateMagicalDamage(_hero, weapon, _learnedSkills);
                else
                    dmgRange = StatManager.CalculatePhysicalDamage(_hero, weapon, _learnedSkills);

                int baseDmg = _rnd.Next(dmgRange.min, dmgRange.max +1);
                int skillDmg = (int)effectVal;

                int elementBonus = StatManager.CalculateElementBonus(_learnedSkills, slot.Skill.Element);
                int finalDmg = baseDmg + skillDmg + elementBonus;

                int critChance = StatManager.CalculateCritChance(_hero, equipment, _learnedSkills);
                bool isCrit = _rnd.Next(100) < critChance;
                if (isCrit) finalDmg *=2;

                if (isMage)
                {
                    int vType =0;
                    switch (slot.Skill.Element)
                    {
                        case SkillElement.Fire: vType =1; break;
                        case SkillElement.Ice: vType =2; break;
                        case SkillElement.Dark: vType =3; break;
                        case SkillElement.Lightning: vType =4; break;
                        case SkillElement.Poison: vType =5; break;
                    }

                    if (slot.Skill.Name.Contains("Zincirleme") || slot.Skill.Name.Contains("Chain"))
                    {
                        var targets = _enemies.Where(e => e.CurrentHP >0)
                            .OrderBy(e => Math.Sqrt(Math.Pow(e.X - _mousePos.X,2) + Math.Pow(e.Y - _mousePos.Y,2)))
                            .Take(5)
                            .ToList();

                        float lastX = _player.Center.X, lastY = _player.Center.Y;
                        foreach (var target in targets)
                        {
                            _effects.Add(new VisualEffect
                            {
                                X = lastX,
                                Y = lastY,
                                EffectType =15,
                                TargetX = target.Center.X,
                                TargetY = target.Center.Y,
                                Color = Color.Yellow,
                                LifeTime =20,
                                InitialLifeTime =20
                            });

                            ApplyDamageToEnemy(target, finalDmg, isCrit);
                            lastX = target.Center.X;
                            lastY = target.Center.Y;
                            finalDmg = (int)(finalDmg *0.8);
                        }
                        skillSuccess = targets.Count >0;
                    }
                    else if (slot.Skill.Element == SkillElement.Fire)
                    {
                        var proj = new SkillProjectile(_player.Center.X, _player.Center.Y, _mousePos.X, _mousePos.Y, finalDmg, enemy: false, isCrit: isCrit, visualType: vType);
                        proj.IsAoE = true;
                        proj.AoERadius =60 + (slot.Skill.CurrentLevel *10);
                        _projectiles.Add(proj);
                        skillSuccess = true;
                    }
                    else
                    {
                        _projectiles.Add(new SkillProjectile(_player.Center.X, _player.Center.Y, _mousePos.X, _mousePos.Y, finalDmg, enemy: false, isCrit: isCrit, visualType: vType));
                        skillSuccess = true;
                    }
                }
                else
                {
                    bool isAoEMelee = slot.Skill.Name.Contains("Dönme") || slot.Skill.Name.Contains("Whirl") ||
                        slot.Skill.Name.Contains("Ezici") || slot.Skill.Name.Contains("Crush");

                    float range = isAoEMelee ?120f :100f;

                    float mdx = _mousePos.X - _player.Center.X;
                    float mdy = _mousePos.Y - _player.Center.Y;
                    float mDist = (float)Math.Sqrt(mdx * mdx + mdy * mdy);
                    if (mDist <1f) mDist =1f;
                    float dirX = mdx / mDist;
                    float dirY = mdy / mDist;
                    float facingAngle = (float)Math.Atan2(dirY, dirX);

                    int effectType = isAoEMelee ?11 :10;
                    Color slashColor = slot.Skill.Name.Contains("Ezici") ? Color.Red : Color.Silver;

                    _effects.Add(new VisualEffect
                    {
                        X = _player.Center.X,
                        Y = _player.Center.Y,
                        EffectType = effectType,
                        Size = (int)range,
                        Color = slashColor,
                        LifeTime =15,
                        InitialLifeTime =15,
                        Angle = facingAngle,
                        MaxRadius = (int)range
                    });

                    int hitCount =0;
                    float rangeSq = range * range;
                    for (int ei =0; ei < _enemies.Count; ei++)
                    {
                        var entity = _enemies[ei];
                        if (entity.CurrentHP <=0) continue;

                        float edx = entity.Center.X - _player.Center.X;
                        float edy = entity.Center.Y - _player.Center.Y;
                        float distSq = edx * edx + edy * edy;

                        if (distSq <= rangeSq)
                        {
                            if (isAoEMelee)
                            {
                                ApplyDamageToEnemy(entity, finalDmg, isCrit);
                                hitCount++;
                            }
                            else
                            {
                                float entityAngle = (float)Math.Atan2(edy, edx);
                                float angleDiff = Math.Abs(entityAngle - facingAngle);
                                if (angleDiff > Math.PI) angleDiff = (float)(2 * Math.PI - angleDiff);

                                if (angleDiff < Math.PI /3)
                                {
                                    ApplyDamageToEnemy(entity, finalDmg, isCrit);
                                    hitCount++;
                                }
                            }
                        }
                    }
                    skillSuccess = hitCount >0 || isAoEMelee;
                }

                if (isMage)
                {
                    string n = slot.Skill.Name;
                    int castEffectType =0;
                    Color castColor = Color.Cyan;

                    if (n.Contains("Fire") || n.Contains("Ateş") || n.Contains("Alev"))
                    {
                        castEffectType =12;
                        castColor = Color.Orange;
                    }
                    else if (n.Contains("Ice") || n.Contains("Buz") || n.Contains("Frost"))
                    {
                        castEffectType =13;
                        castColor = Color.LightCyan;
                    }
                    else if (n.Contains("Arcane") || n.Contains("Karanlık"))
                    {
                        castEffectType =14;
                        castColor = Color.MediumPurple;
                    }

                    _effects.Add(new VisualEffect
                    {
                        X = _player.Center.X,
                        Y = _player.Center.Y,
                        EffectType = castEffectType,
                        Color = castColor,
                        LifeTime =12,
                        InitialLifeTime =12,
                        Size =40
                    });
                }
            }

            CharacterRepository repo = new CharacterRepository();
            repo.UpdateProgress(_hero);
            if (base.ParentForm is FormMain m) m.UpdateBars(null);
            this.OnStatsUpdated?.Invoke(this, EventArgs.Empty);
        }
    }

    private async void StartBattleEndSequence(bool victory)
    {
        _isBattleEnding = true;
        await Task.Delay(1000);
        StopGameLoop();

        this.OnBattleEnded?.Invoke(this, victory);
    }

    public void ShowBattleResults(string message, Action onPrimary, string primaryText = "DEVAM ET", Action onSecondary = null, string secondaryText = "")
    {
        _showResults = true;
        _resultMessage = message;
        _onPrimary = onPrimary;
        _primaryBtnText = primaryText;
        _onSecondary = onSecondary;
        _secondaryBtnText = secondaryText;
        _skgl?.Invalidate();
    }

    private void UpdateTownLayout()
    {
        if (!_isTownMode)
        {
            return;
        }
        var (w, h) = GetArenaSize();
        int cx = w /2;
        int cy = h /2;

        for (int i =0; i < _npcs.Count; i++)
        {
            NpcEntity npc = _npcs[i];
            switch (npc.Type)
            {
                case Enums.NpcType.Merchant:
                    npc.X = cx -150;
                    npc.Y = cy -100;
                    break;
                case Enums.NpcType.BlackSmith:
                    npc.X = cx +100;
                    npc.Y = cy -120;
                    break;
                case Enums.NpcType.StorageKeeper:
                    npc.X = cx -140;
                    npc.Y = cy +80;
                    break;
                case Enums.NpcType.Teleporter:
                    npc.X = cx +120;
                    npc.Y = cy +80;
                    break;
                case Enums.NpcType.ArenaMaster:
                    npc.X = w -100;
                    npc.Y = cy -20;
                    break;
            }
        }

        if (_btnMap != null)
        {
            _btnMap.Location = new Point(w -180,20);
        }
    }

    private void InitTownEntities()
    {
        _npcs = new List<NpcEntity>
        {
            new NpcEntity("MARKET", Enums.NpcType.Merchant,0,0),
            new NpcEntity("IŞINLAYICI", Enums.NpcType.Teleporter,0,0),
            new NpcEntity("DEPOCU", Enums.NpcType.StorageKeeper,0,0)
            {
                Color = Color.Brown
            },
            new NpcEntity("DEMİRCİ", Enums.NpcType.BlackSmith,0,0)
            {
                Color = Color.DarkSlateGray
            },
            new NpcEntity("ARENA GUARD", Enums.NpcType.ArenaMaster,0,0)
            {
                Color = Color.Red
            }
        };
    }

    private void UpdateEffects()
    {
        // Use backwards iteration to safely remove - but batch removals
   int writeIndex = 0;
        int effectCount = _effects.Count;
  
        for (int i = 0; i < effectCount; i++)
   {
     var fx = _effects[i];
      fx.LifeTime--;
            
     if (fx.IsText)
      {
  fx.Y -= 1f;
    }
     
   // Keep alive effects - swap to front
         if (fx.LifeTime > 0)
       {
             if (writeIndex != i)
       {
    _effects[writeIndex] = fx;
    }
       writeIndex++;
   }
        }
  
        // Trim dead effects in one operation
        if (writeIndex < effectCount)
        {
       _effects.RemoveRange(writeIndex, effectCount - writeIndex);
        }
    }
}
