using Microsoft.Data.SqlClient;
using rpg_deneme.Data; // Repository'ye erişmek için
using rpg_deneme.Models; // ItemInstance modelini tanımak için
using System.Collections.Generic; // List<> kullanabilmek için

namespace rpg_deneme.Business
{
    public class InventoryManager
    {
        // Data katmanındaki (SQL işlerini yapan) sınıfı burada tanımlıyoruz.
        // "private readonly" demek: Bu sınıf sadece burada kullanılacak ve değiştirilemeyecek.
        private readonly InventoryRepository _repo = new InventoryRepository();

        /// <summary>
        /// Karakterin ID'sine göre üzerindeki eşyaları getirir.
        /// </summary>
        public List<ItemInstance> GetInventory(int charId)
        {
            // Business katmanı olarak Data katmanına emri veriyoruz:
            // "Git bana bu karakterin eşyalarını SQL'den çek getir."
            return _repo.GetCharacterInventory(charId);
        }
        public bool MoveItemToSlot(long instanceId, int targetSlotIndex)
        {
            // İleride buraya kural ekleyebiliriz (Örn: Çanta kilitli mi?)
            return _repo.MoveItem(instanceId, targetSlotIndex);
        }
        // Eşyayı hem konum (Equipment/Inventory) hem de slot olarak taşır.
        // Özellikle "Üzerimden çıkarıp çantanın şu kutusuna koy" dediğimizde kullanılır.
        public bool MoveItemToSlotAndLocation(long instanceId, Core.Enums.ItemLocation newLocation, int targetSlotIndex)
        {
            // Repository'deki MoveItemLocation metodunu çağırır
            return _repo.MoveItemLocation(instanceId, newLocation, targetSlotIndex);
        }

        public bool AddItemToInventory(ItemInstance item)
        {
            // Use authoritative template info but allow caller-provided item values to override
            var templateBasic = _repo.GetTemplateBasicInfo(item.TemplateID);

            // Determine stackability: prefer explicit item.IsStackable, fall back to template
            bool isStackable = item.IsStackable || templateBasic.IsStackable;

            // Determine max stack: prefer item.MaxStack if >1, otherwise template value, otherwise default20
            int maxStackLimit =1;
            if (isStackable)
            {
                if (item.MaxStack >1) maxStackLimit = item.MaxStack;
                else if (templateBasic.MaxStack >1) maxStackLimit = templateBasic.MaxStack;
                else maxStackLimit =20; // fallback default
            }

            // --- DAĞITIM DÖNGÜSÜ (ALGORİTMA DÜZELTİLDİ) ---
            // Elimizdeki 'item.Count' bitene kadar slotlara dağıtacağız.

            while (item.Count >0)
            {
                //1. Durum: Stacklenebilir ise, üzerine koyabileceğimiz YARIM DOLU bir slot var mı?
                ItemInstance existingStack = null;
                if (isStackable)
                {
                    existingStack = _repo.FindStackableItemWithCapacity(item.OwnerID, item.TemplateID, maxStackLimit);
                }

                if (existingStack != null)
                {
                    // --- MEVCUT SLOTA EKLEME ---
                    // O slotta ne kadar boşluk var?
                    int spaceAvailable = maxStackLimit - existingStack.Count;

                    // Ne kadarını oraya koyabiliriz?
                    int amountToAdd = System.Math.Min(spaceAvailable, item.Count);

                    // Veritabanını güncelle
                    bool success = _repo.IncrementItemCount(existingStack.InstanceID, amountToAdd);
                    if (!success) return false; // Kritik hata

                    // Elimizdeki miktarı düş
                    item.Count -= amountToAdd;
                }
                else
                {
                    // --- YENİ SLOT AÇMA ---
                    // Boş slot bul
                    int emptySlot = _repo.FindFirstEmptyInventorySlot(item.OwnerID);
                    if (emptySlot == -1)
                    {
                        // Çanta tamamen doldu ve elimizde hala eşya var!
                        // Kalan eşya yerde kalır veya işlem iptal edilir.
                        // Şimdilik false dönüyoruz (Satın alma yarım kalabilir)
                        return false;
                    }

                    // Yeni slota ne kadar koyabiliriz? (MaxStack kadar)
                    int amountToInsert = System.Math.Min(maxStackLimit, item.Count);

                    // Yeni nesne oluşturup ekle
                    item.SlotIndex = emptySlot;

                    // DB'ye eklerken 'Count' parametresini 'amountToInsert' olarak kullanmalıyız, 'item.Count' değil!
                    // Bu yüzden Repository metodunu çağırmadan önce geçici bir kopya veya parametre ayarı lazım.
                    // AddItem metodun "item.Count"u DB'ye yazıyor. O yüzden:

                    // Geçici olarak Count'u ayarla
                    int originalCount = item.Count;
                    item.Count = amountToInsert;

                    bool success = InsertNewItemToDB(item); // Aşağıdaki yardımcı metot

                    // Count'u geri yükle ki döngü hesabımız bozulmasın
                    item.Count = originalCount;

                    if (!success) return false;

                    // Elimizdeki miktarı düş
                    item.Count -= amountToInsert;
                }
            }

            return true; // Hepsi başarıyla dağıtıldı
        }
        private bool InsertNewItemToDB(ItemInstance item)
        {
            using (var conn = DatabaseHelper.GetConnection())
            {
                conn.Open();
                string sql = @"
                INSERT INTO ItemInstances 
                (TemplateID, OwnerID, SlotIndex, Grade, Location, Count, UpgradeLevel) 
                VALUES 
                (@tid, @oid, @slot, @grade, @loc, @count, @upg)";

                SqlCommand cmd = new SqlCommand(sql, conn);
                cmd.Parameters.AddWithValue("@tid", item.TemplateID);
                cmd.Parameters.AddWithValue("@oid", item.OwnerID);
                cmd.Parameters.AddWithValue("@slot", item.SlotIndex);
                cmd.Parameters.AddWithValue("@grade", (byte)item.Grade);
                cmd.Parameters.AddWithValue("@loc", (byte)item.Location);
                cmd.Parameters.AddWithValue("@count", item.Count); // O anki parça sayısı
                cmd.Parameters.AddWithValue("@upg", item.UpgradeLevel);

                return cmd.ExecuteNonQuery() >0;
            }
        }
        // EŞYA BÖLME
        public (bool Success, string Message) SplitItem(ItemInstance item, int amountToSplit)
        {
            if (amountToSplit >= item.Count) return (false, "Hatalı miktar.");
            if (amountToSplit <= 0) return (false, "En az 1 adet bölmelisin.");

            // 1. Boş yer var mı?
            int emptySlot = _repo.FindFirstEmptyInventorySlot(item.OwnerID);
            if (emptySlot == -1) return (false, "Bölmek için boş yer yok!");

            // 2. Yeni parçayı oluştur
            ItemInstance newItem = new ItemInstance
            {
                TemplateID = item.TemplateID,
                OwnerID = item.OwnerID,
                SlotIndex = emptySlot,
                Count = amountToSplit,
                // Diğer özelliklerini kopyala
                Name = item.Name,
                Grade = item.Grade,
                ItemType = item.ItemType,
                IsStackable = item.IsStackable,
                MaxStack = item.MaxStack,
                Location = Core.Enums.ItemLocation.Inventory
            };

            // 3. Veritabanı İşlemleri
            // A. Yeni parçayı kaydet (Mevcut AddItem metodunu kullanabiliriz ama yerini biz belirledik)
            // Direkt INSERT yapalım, helper metodunu kullanabilirsin veya repo çağırabilirsin.
            // Burada AddItemToInventory çağırmıyoruz çünkü o stacklemeye çalışır, biz AYIRMAK istiyoruz.

            // Geçici bir insert metodu veya repository çağrısı:
            // (Not: InventoryRepository'ye InsertItem metodunu public açman gerekebilir veya sql sorgusu yazabilirsin)
            // Şimdilik varsayalım ki repo üzerinden ekliyoruz:
            bool inserted = _repo.AddItemDirectly(newItem); // *Bunu Repo'ya ekleyeceğiz

            if (inserted)
            {
                // B. Eski parçayı azalt
                _repo.ConsumeItem(item.InstanceID, amountToSplit); // Count - amount yapar
                return (true, "Eşya bölündü.");
            }

            return (false, "Veritabanı hatası.");
        }

        // EŞYA BİRLEŞTİRME (Sürükle - Bırak Mantığı)
        public bool MergeItems(ItemInstance sourceItem, ItemInstance targetItem)
        {
            // Temel Kontroller
            if (sourceItem.TemplateID != targetItem.TemplateID) return false; // Aynı eşya değil
            if (!targetItem.IsStackable) return false; // Stacklenemez
            if (targetItem.Count >= targetItem.MaxStack) return false; // Hedef zaten dolu

            // Matematik
            int spaceAvailable = targetItem.MaxStack - targetItem.Count;
            int amountToMove = System.Math.Min(spaceAvailable, sourceItem.Count);

            if (amountToMove <= 0) return false;

            // 1. Hedefi Artır (DB Update)
            bool incSuccess = _repo.IncrementItemCount(targetItem.InstanceID, amountToMove);

            // 2. Kaynağı Azalt (DB Update veya Delete)
            if (incSuccess)
            {
                _repo.ConsumeItem(sourceItem.InstanceID, amountToMove);
                return true;
            }

            return false;
        }
    }
}