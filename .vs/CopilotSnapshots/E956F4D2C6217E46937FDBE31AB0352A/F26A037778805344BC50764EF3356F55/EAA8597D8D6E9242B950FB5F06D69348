using rpg_deneme.Business;
using rpg_deneme.Core; // Enums için
using rpg_deneme.Models;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Timer = System.Windows.Forms.Timer;

namespace rpg_deneme.UI.Controls
{
    public partial class UcArena : UserControl
    {
        private ArenaPanel _arena;
        private Timer _gameLoop;

        // Hotbar:5 slots
        private class HotbarSlot
        {
            public int Index { get; set; }
            public long? InstanceID { get; set; }
            public ItemInstance Item { get; set; }
        }
        private List<HotbarSlot> _hotbar = new List<HotbarSlot>();

        // Varlıklar
        private BattleEntity _player;
        private BattleEntity _enemy;
        private List<Projectile> _projectiles = new List<Projectile>();
        private CharacterModel _hero;

        private InventoryManager _invManager = new InventoryManager();

        private Button _btnMap; // Harita butonu
        public event EventHandler OnMapRequested; // Harita istendiğinde tetiklenecek olay

        // Klavye & Mouse
        private bool _w, _a, _s, _d;
        private Point _mousePos = Point.Empty;

        // Eventler
        public event EventHandler<bool> OnBattleEnded;
        public event EventHandler OnStatsUpdated;

        private LootManager _lootManager = new LootManager();

        // Düşman Saldırı Zamanlayıcısı
        private int _enemyAttackCooldown =0;

        private int _attackDelayMs =1000; // İki saldırı arası bekleme süresi (Milisaniye)
        private DateTime _lastAttackTime = DateTime.MinValue; // Son saldırı zamanı
        private int _manaCostPerHit =0; // Vuruş başı mana bedeli

        private bool _isTownMode = false;
        private List<NpcEntity> _npcs = new List<NpcEntity>();
        public event EventHandler<NpcEntity> OnNpcInteraction; // Sağ tık olayı

        private bool _isBattleEnding = false; // Sadece bu yeterli

        private List<VisualEffect> _effects = new List<VisualEffect>();

        public UcArena()
        {
            this.DoubleBuffered = true;
            this.BackColor = Color.Black;
            SetupArena();
        }

        private void SetupArena()
        {
            _arena = new ArenaPanel();
            _arena.Dock = DockStyle.Fill;
            _arena.BackColor = Color.FromArgb(45,45,48);
            _arena.Paint += Arena_Paint;
            _arena.MouseDown += Arena_MouseDown;
            _arena.MouseMove += (s, e) => _mousePos = e.Location;

            // Hotbar drag/drop
            _arena.AllowDrop = true;
            _arena.DragEnter += Arena_DragEnter;
            _arena.DragDrop += Arena_DragDrop;

            this.Controls.Add(_arena);
            this.Click += (s, e) => this.Focus();

            // Initialize hotbar
            for (int i =0; i <5; i++) _hotbar.Add(new HotbarSlot { Index = i });
        }

        private void LoadHotbarFromSession()
        {
            for (int i =0; i <5; i++)
            {
                var id = Core.SessionManager.HotbarSlots[i];
                if (id.HasValue && _hero != null)
                {
                    var inv = _invManager.GetInventory(_hero.CharacterID);
                    var it = inv.FirstOrDefault(x => x.InstanceID == id.Value);
                    if (it != null)
                    {
                        _hotbar[i].InstanceID = id.Value;
                        _hotbar[i].Item = it;
                        continue;
                    }
                }
                _hotbar[i].InstanceID = null;
                _hotbar[i].Item = null;
            }
        }

        private void SaveHotbarToSession()
        {
            for (int i =0; i <5; i++)
                Core.SessionManager.HotbarSlots[i] = _hotbar[i].InstanceID;
        }

        public void StartBattle(CharacterModel hero, BattleEntity enemyTemplate)
        {
            _hero = hero;
            LoadHotbarFromSession();
            _projectiles.Clear();
            _w = _a = _s = _d = false;

            _isBattleEnding = false;

            var inventory = _invManager.GetInventory(hero.CharacterID);
            var equippedWeapon = inventory.FirstOrDefault(x => x.Location == Enums.ItemLocation.Equipment && x.ItemType == Enums.ItemType.Weapon);

            int calculatedDamage =0;
            var equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
            int calculatedDefense = StatManager.CalculateTotalDefense(_hero, equippedItems);

            float attackSpeed = StatManager.CalculateAttackSpeed(hero, equippedWeapon);
            _attackDelayMs = (int)(1000f / attackSpeed);
            _manaCostPerHit = StatManager.CalculateAttackManaCost(hero);

            if (_hero.Class == (byte)Enums.CharacterClass.Mage)
                calculatedDamage = StatManager.CalculateMagicalDamage(_hero, equippedWeapon);
            else
                calculatedDamage = StatManager.CalculatePhysicalDamage(_hero, equippedWeapon);

            int maxHp = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);

            // center player
            int startX = this.Width /2 -16;
            int startY = this.Height /2 -16;

            _player = new BattleEntity { X = startX, Y = startY, Width =32, Height =32, Speed =5.0f, MaxHP = maxHp, CurrentHP = _hero.HP, Damage = calculatedDamage, Defense = calculatedDefense };
            if (_player.CurrentHP > _player.MaxHP) _player.CurrentHP = _player.MaxHP;

            _enemy = new BattleEntity { X = this.Width -100, Y = this.Height /2 -20, Width = enemyTemplate.Width, Height = enemyTemplate.Height, Speed = enemyTemplate.Speed, MaxHP = enemyTemplate.MaxHP, CurrentHP = enemyTemplate.MaxHP, Damage = enemyTemplate.Damage };

            if (_gameLoop == null)
            {
                _gameLoop = new Timer { Interval =16 };
                _gameLoop.Tick += GameTick;
            }
            _gameLoop.Start();
            this.Focus();
        }

        public void HandleKeyDown(Keys key) { SetKey(key, true); }
        public void HandleKeyUp(Keys key) { SetKey(key, false); }

        // Accept numeric keys for hotbar (1-5)
        public void HandleHotbarKey(Keys key)
        {
            int index = -1;
            if (key >= Keys.D1 && key <= Keys.D5) index = key - Keys.D1;
            else if (key >= Keys.NumPad1 && key <= Keys.NumPad5) index = key - Keys.NumPad1;
            if (index >=0) UseHotbarSlot(index);
        }

        private void SetKey(Keys key, bool pressed)
        {
            if (key == Keys.W) _w = pressed;
            if (key == Keys.S) _s = pressed;
            if (key == Keys.A) _a = pressed;
            if (key == Keys.D) _d = pressed;
        }

        private void GameTick(object sender, EventArgs e)
        {
            if (_player == null) return;

            if (_isBattleEnding)
            {
                UpdateEffects();
                _arena.Invalidate();
                return;
            }

            UpdatePlayer();
            UpdateProjectiles();
            UpdateEffects();
            UpdateHotbarState();

            if (!_isTownMode && _enemy != null)
                UpdateEnemy();

            _arena.Invalidate();
        }

        private void UpdateHotbarState()
        {
            if (_hero == null) return;
            var inv = _invManager.GetInventory(_hero.CharacterID);
            for (int i =0; i < _hotbar.Count; i++)
            {
                var slot = _hotbar[i];
                if (slot.InstanceID.HasValue)
                {
                    var it = inv.FirstOrDefault(x => x.InstanceID == slot.InstanceID.Value);
                    if (it == null)
                    {
                        slot.InstanceID = null;
                        slot.Item = null;
                    }
                    else
                    {
                        slot.Item = it;
                    }
                }
            }
        }

        private void UpdatePlayer()
        {
            float proposedX = _player.X;
            float proposedY = _player.Y;

            if (_w && _player.Y >0) proposedY -= _player.Speed;
            if (_s && _player.Y < _arena.Height - _player.Height) proposedY += _player.Speed;
            if (_a && _player.X >0) proposedX -= _player.Speed;
            if (_d && _player.X < _arena.Width - _player.Width) proposedX += _player.Speed;

            var proposedRect = new Rectangle((int)proposedX, (int)proposedY, _player.Width, _player.Height);
            bool collides = false;

            if (_isTownMode)
            {
                foreach (var npc in _npcs)
                {
                    var npcRect = new Rectangle((int)npc.X, (int)npc.Y, npc.Width, npc.Height);
                    if (proposedRect.IntersectsWith(npcRect)) { collides = true; break; }
                }
            }
            else
            {
                if (_enemy != null)
                {
                    var enemyRect = new Rectangle((int)_enemy.X, (int)_enemy.Y, _enemy.Width, _enemy.Height);
                    if (proposedRect.IntersectsWith(enemyRect)) collides = true;
                }
            }

            if (!collides)
            {
                _player.X = proposedX;
                _player.Y = proposedY;
            }
        }

        private void UpdateEnemy()
        {
            if (_enemy.CurrentHP <=0) return;
            if (_enemyAttackCooldown >0) _enemyAttackCooldown--;

            float dist = Distance(_enemy.Center.X, _enemy.Center.Y, _player.Center.X, _player.Center.Y);
            float minSeparation = (Math.Max(_enemy.Width, _player.Width) + Math.Max(_enemy.Height, _player.Height)) /2f;
            if (dist > minSeparation +1f)
            {
                float dx = _player.X - _enemy.X;
                float dy = _player.Y - _enemy.Y;
                float moveDist = _enemy.Speed;
                if (dist - moveDist < minSeparation +1f) moveDist = Math.Max(0f, dist - (minSeparation +1f));
                if (moveDist >0 && dist >0)
                {
                    _enemy.X += (dx / dist) * moveDist;
                    _enemy.Y += (dy / dist) * moveDist;
                }
            }

            float attackRange = (Math.Max(_enemy.Width, _player.Width) + Math.Max(_enemy.Height, _player.Height)) /2f +8f;
            if (dist <= attackRange)
            {
                if (_enemyAttackCooldown <=0)
                {
                    ApplyDamageToPlayer(_enemy.Damage);
                    _enemyAttackCooldown =60;
                    float dx = _player.X - _enemy.X;
                    float dy = _player.Y - _enemy.Y;
                    _player.X += dx *2;
                    _player.Y += dy *2;
                }
            }
        }

        private void ApplyDamageToPlayer(int incomingDamage)
        {
            if (_isBattleEnding) return;
            int reducedDamage = incomingDamage - _player.Defense;
            if (reducedDamage <1) reducedDamage =1;
            _player.CurrentHP -= reducedDamage;
            _hero.HP = _player.CurrentHP;
            OnStatsUpdated?.Invoke(this, EventArgs.Empty);
            if (_player.CurrentHP <=0)
            {
                _player.CurrentHP =0;
                StartBattleEndSequence(false);
            }
        }

        private void UpdateProjectiles()
        {
            for (int i = _projectiles.Count -1; i >=0; i--)
            {
                var proj = _projectiles[i];
                proj.Move();
                if (proj.X <0 || proj.X > _arena.Width || proj.Y <0 || proj.Y > _arena.Height)
                {
                    _projectiles.RemoveAt(i);
                    continue;
                }
                if (_enemy != null && _enemy.CurrentHP >0 && proj.Bounds.IntersectsWith(_enemy.Bounds))
                {
                    ApplyDamageToEnemy(proj.Damage);
                    _projectiles.RemoveAt(i);
                }
            }
        }

        private void ApplyDamageToEnemy(int dmg)
        {
            _enemy.CurrentHP -= dmg;
            _effects.Add(new VisualEffect { X = _enemy.X +10, Y = _enemy.Y, Text = $"-{dmg}", Color = Color.Yellow, IsText = true, LifeTime =30 });
            if (_enemy.CurrentHP <=0)
            {
                _enemy.CurrentHP =0;
                StartBattleEndSequence(true);
            }
        }

        private void Arena_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(typeof(ItemInstance)))
            {
                var item = (ItemInstance)e.Data.GetData(typeof(ItemInstance));
                if (item != null && item.ItemType == Enums.ItemType.Consumable) { e.Effect = DragDropEffects.Move; return; }
            }
            e.Effect = DragDropEffects.None;
        }

        private void Arena_DragDrop(object sender, DragEventArgs e)
        {
            if (!e.Data.GetDataPresent(typeof(ItemInstance))) return;
            var item = (ItemInstance)e.Data.GetData(typeof(ItemInstance));
            var pt = _arena.PointToClient(new Point(e.X, e.Y));
            for (int i =0; i <5; i++)
            {
                var rect = GetHotbarSlotRect(i);
                if (rect.Contains(pt))
                {
                    _hotbar[i].InstanceID = item.InstanceID;
                    _hotbar[i].Item = item;
                    SaveHotbarToSession();
                    break;
                }
            }
        }

        private Rectangle GetHotbarSlotRect(int index)
        {
            int slotSize =56;
            int gap =8;
            int totalWidth = slotSize *5 + gap *4;
            int startX = (_arena.Width - totalWidth) /2;
            int y = _arena.Height - slotSize -10;
            int x = startX + index * (slotSize + gap);
            return new Rectangle(x, y, slotSize, slotSize);
        }

        private void Arena_MouseDown(object sender, MouseEventArgs e)
        {
            if (_hero == null || _player == null) return;
            if (_isBattleEnding) return;

            // Hotbar priority: if clicking on hotbar
            for (int i =0; i < _hotbar.Count; i++)
            {
                var rect = GetHotbarSlotRect(i);
                if (rect.Contains(e.Location))
                {
                    if (e.Button == MouseButtons.Left)
                    {
                        // Left click clears slot
                        _hotbar[i].InstanceID = null;
                        _hotbar[i].Item = null;
                        SaveHotbarToSession();
                        return;
                    }
                    else if (e.Button == MouseButtons.Right)
                    {
                        // Right click uses the hotbar item
                        UseHotbarSlot(i);
                        return;
                    }
                }
            }

            // If not a hotbar click, proceed with regular interactions
            if (e.Button == MouseButtons.Left)
            {
                // --- KONTROL1: HIZ LİMİTİ (COOLDOWN) ---
                if ((DateTime.Now - _lastAttackTime).TotalMilliseconds < _attackDelayMs)
                {
                    // Henüz hazır değil, işlem yapma
                    return;
                }

                // --- KONTROL2: MANA YETERLİ Mİ? ---
                if (_hero.Mana < _manaCostPerHit)
                {
                    if (!_isTownMode) { if (_hero.Mana < _manaCostPerHit) return; _hero.Mana -= _manaCostPerHit; }
                    return;
                }

                // --- İŞLEM: SALDIRIYI GERÇEKLEŞTİR ---
                _hero.Mana -= _manaCostPerHit;
                _lastAttackTime = DateTime.Now;
                OnStatsUpdated?.Invoke(this, EventArgs.Empty);

                if (_hero.Class == (byte)Enums.CharacterClass.Mage)
                {
                    var proj = new Projectile(_player.Center.X, _player.Center.Y, e.X, e.Y, _player.Damage);
                    _projectiles.Add(proj);
                }
                else
                {
                    // --- WARRIOR / ROGUE: Yakın Dövüş ---
                    _effects.Add(new VisualEffect { X = e.X -10, Y = e.Y -10, Color = Color.WhiteSmoke, IsText = false, Size =20, LifeTime =10 });
                    if (!_isTownMode && _enemy != null && _enemy.Bounds.Contains(e.Location))
                    {
                        float dist = Distance(_player.Center.X, _player.Center.Y, _enemy.Center.X, _enemy.Center.Y);
                        if (dist <80f)
                        {
                            ApplyDamageToEnemy(_player.Damage);
                            _effects.Add(new VisualEffect { X = e.X, Y = e.Y, Color = Color.Red, IsText = false, Size =10, LifeTime =15 });
                        }
                    }
                }
            }

            // SAĞ TIK: NPC Etkileşimi (Sadece Köy Modunda)
            if (_isTownMode && e.Button == MouseButtons.Right)
            {
                foreach (var npc in _npcs)
                {
                    float mouseDist = Distance(e.X, e.Y, npc.X + npc.Width /2, npc.Y + npc.Height /2);
                    if (mouseDist <60)
                    {
                        float playerDist = Distance(_player.Center.X, _player.Center.Y, npc.X + npc.Width /2, npc.Y + npc.Height /2);
                        if (playerDist <150) OnNpcInteraction?.Invoke(this, npc);
                        else MessageBox.Show("Sesini duyuramıyorum, biraz daha yaklaş! (WASD ile yürü)");
                        return;
                    }
                }
            }
        }

        private void UseHotbarSlot(int index)
        {
            if (index <0 || index >= _hotbar.Count) return;
            var slot = _hotbar[index];
            if (slot.InstanceID == null) return;
            if (_hero == null) return;

            var inv = _invManager.GetInventory(_hero.CharacterID);
            var item = inv.FirstOrDefault(x => x.InstanceID == slot.InstanceID.Value);
            if (item == null)
            {
                slot.InstanceID = null; slot.Item = null; SaveHotbarToSession(); return;
            }

            if (item.RemainingCooldownSeconds >0) return;

            var cm = new ConsumableManager();
            var res = cm.UseItem(_hero, item);
            if (res.Success)
            {
                var inv2 = _invManager.GetInventory(_hero.CharacterID);
                var it2 = inv2.FirstOrDefault(x => x.InstanceID == slot.InstanceID.Value);
                if (it2 == null) { slot.InstanceID = null; slot.Item = null; }
                else { slot.Item = it2; }
                OnStatsUpdated?.Invoke(this, EventArgs.Empty);
                SaveHotbarToSession();
            }
        }

        private void Arena_Paint(object sender, PaintEventArgs e)
        {
            if (_player == null) return;
            Graphics g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

            // Player
            Brush playerColor = _hero != null && _hero.Class == (byte)Enums.CharacterClass.Mage ? Brushes.CornflowerBlue : Brushes.DarkOrange;
            g.FillRectangle(playerColor, _player.X, _player.Y, _player.Width, _player.Height);
            if (_player.MaxHP >0)
            {
                float playerHpPct = (float)_player.CurrentHP / _player.MaxHP;
                g.FillRectangle(Brushes.Red, _player.X, _player.Y -10, _player.Width,5);
                g.FillRectangle(Brushes.Lime, _player.X, _player.Y -10, _player.Width * playerHpPct,5);
            }

            // Projectiles
            foreach (var proj in _projectiles) g.FillEllipse(Brushes.Cyan, proj.X, proj.Y, proj.Size, proj.Size);

            // NPCs
            if (_isTownMode)
            {
                using (Font font = new Font("Segoe UI",8, FontStyle.Bold))
                using (Brush textBrush = new SolidBrush(Color.White))
                {
                    foreach (var npc in _npcs)
                    {
                        using (Brush b = new SolidBrush(npc.Color)) g.FillRectangle(b, npc.X, npc.Y, npc.Width, npc.Height);
                        SizeF size = g.MeasureString(npc.Name, font);
                        float txtX = npc.X + (npc.Width - size.Width) /2;
                        g.DrawString(npc.Name, font, textBrush, txtX, npc.Y -15);
                    }
                }
            }

            // Enemy
            if (_enemy != null && _enemy.CurrentHP >0)
            {
                g.FillRectangle(Brushes.Crimson, _enemy.X, _enemy.Y, _enemy.Width, _enemy.Height);
                float enemyHpPct = (float)_enemy.CurrentHP / _enemy.MaxHP;
                g.FillRectangle(Brushes.DarkRed, _enemy.X, _enemy.Y -10, _enemy.Width,5);
                g.FillRectangle(Brushes.OrangeRed, _enemy.X, _enemy.Y -10, _enemy.Width * enemyHpPct,5);
            }

            // Effects
            foreach (var fx in _effects)
            {
                if (fx.IsText)
                {
                    using (Font f = new Font("Segoe UI",12, FontStyle.Bold))
                    {
                        e.Graphics.DrawString(fx.Text, f, Brushes.Black, fx.X +1, fx.Y +1);
                        using (Brush b = new SolidBrush(fx.Color)) e.Graphics.DrawString(fx.Text, f, b, fx.X, fx.Y);
                    }
                }
                else
                {
                    using (Pen p = new Pen(fx.Color,3))
                    {
                        e.Graphics.DrawLine(p, fx.X, fx.Y, fx.X + fx.Size, fx.Y + fx.Size);
                        e.Graphics.DrawLine(p, fx.X + fx.Size, fx.Y, fx.X, fx.Y + fx.Size);
                    }
                }
            }

            // Hotbar
            DrawHotbar(g);
        }

        private void DrawHotbar(Graphics g)
        {
            for (int i =0; i < _hotbar.Count; i++)
            {
                var rect = GetHotbarSlotRect(i);
                using (Brush b = new SolidBrush(Color.FromArgb(50,50,50)))
                using (Pen p = new Pen(Color.DimGray)) { g.FillRectangle(b, rect); g.DrawRectangle(p, rect); }

                var slot = _hotbar[i];
                if (slot.InstanceID.HasValue && slot.Item != null)
                {
                    var color = GetHotbarColor(slot.Item.Grade, slot.Item.ItemType);
                    Rectangle inner = new Rectangle(rect.X +4, rect.Y +4, rect.Width -8, rect.Height -8);
                    using (Brush ib = new SolidBrush(color)) g.FillRectangle(ib, inner);

                    // Hover name
                    if (rect.Contains(_mousePos))
                    {
                        using (Font f = new Font("Segoe UI",8))
                        using (Brush fb = new SolidBrush(Color.White)) g.DrawString(slot.Item.Name, f, fb, rect.X, rect.Y -16);
                    }

                    if (slot.Item.IsStackable && slot.Item.Count >1)
                    {
                        using (Font f = new Font("Segoe UI",9, FontStyle.Bold))
                        using (Brush fb = new SolidBrush(Color.White))
                        {
                            string txt = slot.Item.Count.ToString();
                            var sz = g.MeasureString(txt, f);
                            g.DrawString(txt, f, fb, rect.Right - sz.Width -6, rect.Bottom - sz.Height -6);
                        }
                    }

                    int rem = slot.Item.RemainingCooldownSeconds;
                    int cd = slot.Item.Cooldown;
                    if (cd >0 && rem >0)
                    {
                        float frac = Math.Max(0f, Math.Min(1f, (float)rem / cd));
                        using (Brush cb = new SolidBrush(Color.FromArgb(180, Color.Black)))
                        {
                            int pad =6;
                            Rectangle pieRect = new Rectangle(rect.X + pad, rect.Y + pad, rect.Width - pad *2, rect.Height - pad *2);
                            float sweep =360f * frac;
                            g.FillPie(cb, pieRect, -90, sweep);
                        }
                        using (Font f = new Font("Segoe UI",10, FontStyle.Bold))
                        using (Brush fb = new SolidBrush(Color.White))
                        {
                            string s = rem.ToString();
                            var sz = g.MeasureString(s, f);
                            g.DrawString(s, f, fb, rect.X + (rect.Width - sz.Width) /2, rect.Y + (rect.Height - sz.Height) /2);
                        }
                    }
                }
                else
                {
                    using (Font f = new Font("Segoe UI",9, FontStyle.Regular))
                    using (Brush fb = new SolidBrush(Color.Gray))
                    {
                        string s = (i +1).ToString();
                        var sz = g.MeasureString(s, f);
                        g.DrawString(s, f, fb, rect.X +6, rect.Y +6);
                    }
                }
            }
        }

        private Color GetHotbarColor(Enums.ItemGrade grade, Enums.ItemType itemType)
        {
            if (itemType == Enums.ItemType.Consumable) return Color.MediumSeaGreen;
            return grade switch
            {
                Enums.ItemGrade.Common => Color.WhiteSmoke,
                Enums.ItemGrade.Rare => Color.CornflowerBlue,
                Enums.ItemGrade.Epic => Color.MediumPurple,
                Enums.ItemGrade.Legendary => Color.Orange,
                _ => Color.Gray,
            };
        }

        public void StartTown(CharacterModel hero)
        {
            _isBattleEnding = false;
            _hero = hero;
            LoadHotbarFromSession();
            _isTownMode = true;
            _projectiles.Clear();
            _npcs.Clear();
            _w = _a = _s = _d = false;
            InitTownEntities();
            UpdateTownLayout();

            int w = this.Width >0 ? this.Width :1024;
            int h = this.Height >0 ? this.Height :720;
            int maxHp = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);

            _player = new BattleEntity { X = w /2 -16, Y = h /2 -16, Width =32, Height =32, Speed =5.0f, MaxHP = maxHp, CurrentHP = _hero.HP, Damage =0, Defense =0 };

            _npcs.Add(new NpcEntity("MARKET", Enums.NpcType.Merchant,100, h /2 -20));
            _npcs.Add(new NpcEntity("IŞINLAYICI", Enums.NpcType.Teleporter, this.Width -140, h /2 -20));

            if (_gameLoop == null) { _gameLoop = new Timer { Interval =16 }; _gameLoop.Tick += GameTick; }
            _gameLoop.Start();
            this.Focus();
        }

        // Savaş sırasında statları güncelleyen kritik metod
        public void RecalculatePlayerStats()
        {
            if (_hero == null || _player == null) return;
            var inventory = _invManager.GetInventory(_hero.CharacterID);
            var equippedWeapon = inventory.FirstOrDefault(x => x.Location == Enums.ItemLocation.Equipment && x.ItemType == Enums.ItemType.Weapon);
            var equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
            int newDamage = _hero.Class == (byte)Enums.CharacterClass.Mage ? StatManager.CalculateMagicalDamage(_hero, equippedWeapon) : StatManager.CalculatePhysicalDamage(_hero, equippedWeapon);
            int newDefense = StatManager.CalculateTotalDefense(_hero, equippedItems);
            _player.Damage = newDamage;
            _player.Defense = newDefense;
        }

        private void InitTownEntities()
        {
            _npcs.Clear();
            _npcs.Add(new NpcEntity("MARKET", Enums.NpcType.Merchant,0,0));
            _npcs.Add(new NpcEntity("IŞINLAYICI", Enums.NpcType.Teleporter,0,0));
        }

        private void UpdateTownLayout()
        {
            if (!_isTownMode) return;
            int w = this.Width;
            int h = this.Height;
            int centerY = h /2 -20;
            foreach (var npc in _npcs)
            {
                switch (npc.Type)
                {
                    case Enums.NpcType.Merchant: npc.X =100; npc.Y = centerY; break;
                    case Enums.NpcType.Teleporter: npc.X = w -140; npc.Y = centerY; break;
                }
            }
            if (_btnMap != null) _btnMap.Location = new Point(w -180,20);
        }

        // "async" ekledik
        private async void StartBattleEndSequence(bool victory)
        {
            _isBattleEnding = true;
            await System.Threading.Tasks.Task.Delay(1000);
            _gameLoop.Stop();
            _isBattleEnding = false;
            OnBattleEnded?.Invoke(this, victory);
        }

        public class VisualEffect
        {
            public float X { get; set; }
            public float Y { get; set; }
            public string Text { get; set; }
            public Color Color { get; set; }
            public int LifeTime { get; set; }
            public bool IsText { get; set; }
            public float Angle { get; set; }
            public int Size { get; set; }
        }

        private void UpdateEffects()
        {
            for (int i = _effects.Count -1; i >=0; i--)
            {
                var fx = _effects[i]; fx.LifeTime--; if (fx.IsText) fx.Y -=1.0f; if (fx.LifeTime <=0) _effects.RemoveAt(i);
            }
        }

        private float Distance(float x1, float y1, float x2, float y2) => (float)Math.Sqrt(Math.Pow(x2 - x1,2) + Math.Pow(y2 - y1,2));
    }
}