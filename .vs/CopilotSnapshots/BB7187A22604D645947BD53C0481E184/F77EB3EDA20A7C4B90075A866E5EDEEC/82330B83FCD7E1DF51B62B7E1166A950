using Microsoft.Data.SqlClient;
using rpg_deneme.Core;
using rpg_deneme.Data; // Repository'ye erişmek için
using rpg_deneme.Models; // ItemInstance modelini tanımak için
using System.Collections.Generic; // List<> kullanabilmek için

namespace rpg_deneme.Business
{
    public class InventoryManager
    {
        // Data katmanındaki (SQL işlerini yapan) sınıfı burada tanımlıyoruz.
        // "private readonly" demek: Bu sınıf sadece burada kullanılacak ve değiştirilemeyecek.
        private readonly InventoryRepository _repo = new InventoryRepository();

        /// <summary>
        /// Karakterin ID'sine göre üzerindeki eşyaları getirir.
        /// </summary>
        public List<ItemInstance> GetInventory(int charId)
        {
            // Business katmanı olarak Data katmanına emri veriyoruz:
            // "Git bana bu karakterin eşyalarını SQL'den çek getir."
            return _repo.GetCharacterInventory(charId);
        }
        public bool MoveItemToSlot(long instanceId, int targetSlotIndex)
        {
            // İleride buraya kural ekleyebiliriz (Örn: Çanta kilitli mi?)
            return _repo.MoveItem(instanceId, targetSlotIndex);
        }
        // Eşyayı hem konum (Equipment/Inventory) hem de slot olarak taşır.
        // Özellikle "Üzerimden çıkarıp çantanın şu kutusuna koy" dediğimizde kullanılır.
        public bool MoveItemToSlotAndLocation(long instanceId, Core.Enums.ItemLocation newLocation, int targetSlotIndex)
        {
            // Repository'deki MoveItemLocation metodunu çağırır
            return _repo.MoveItemLocation(instanceId, newLocation, targetSlotIndex);
        }

        public bool AddItemToInventory(ItemInstance item)
        {
            // Use authoritative template info but allow caller-provided item values to override
            var templateBasic = _repo.GetTemplateBasicInfo(item.TemplateID);

            // Determine stackability: prefer explicit item.IsStackable, fall back to template
            bool isStackable = item.IsStackable || templateBasic.IsStackable;

            // Determine max stack: prefer item.MaxStack if >1, otherwise template value, otherwise default20
            int maxStackLimit =1;
            if (isStackable)
            {
                if (item.MaxStack >1) maxStackLimit = item.MaxStack;
                else if (templateBasic.MaxStack >1) maxStackLimit = templateBasic.MaxStack;
                else maxStackLimit =20; // fallback default
            }

            // --- DAĞITIM DÖNGÜSÜ (ALGORİTMA DÜZELTİLDİ) ---
            // Elimizdeki 'item.Count' bitene kadar slotlara dağıtacağız.

            while (item.Count >0)
            {
                //1. Durum: Stacklenebilir ise, üzerine koyabileceğimiz YARIM DOLU bir slot var mı?
                ItemInstance existingStack = null;
                if (isStackable)
                {
                    existingStack = _repo.FindStackableItemWithCapacity(item.OwnerID, item.TemplateID, maxStackLimit);
                }

                if (existingStack != null)
                {
                    // --- MEVCUT SLOTA EKLEME ---
                    // O slotta ne kadar boşluk var?
                    int spaceAvailable = maxStackLimit - existingStack.Count;

                    // Ne kadarını oraya koyabiliriz?
                    int amountToAdd = System.Math.Min(spaceAvailable, item.Count);

                    // Veritabanını güncelle
                    bool success = _repo.IncrementItemCount(existingStack.InstanceID, amountToAdd);
                    if (!success) return false; // Kritik hata

                    // Elimizdeki miktarı düş
                    item.Count -= amountToAdd;
                }
                else
                {
                    // --- YENİ SLOT AÇMA ---
                    // Boş slot bul
                    int emptySlot = _repo.FindFirstEmptyInventorySlot(item.OwnerID);
                    if (emptySlot == -1)
                    {
                        // Çanta tamamen doldu ve elimizde hala eşya var!
                        // Kalan eşya yerde kalır veya işlem iptal edilir.
                        // Şimdilik false dönüyoruz (Satın alma yarım kalabilir)
                        return false;
                    }

                    // Yeni slota ne kadar koyabiliriz? (MaxStack kadar)
                    int amountToInsert = System.Math.Min(maxStackLimit, item.Count);

                    // Yeni nesne oluşturup ekle
                    item.SlotIndex = emptySlot;

                    // DB'ye eklerken 'Count' parametresini 'amountToInsert' olarak kullanmalıyız, 'item.Count' değil!
                    // Bu yüzden Repository metodunu çağırmadan önce geçici bir kopya veya parametre ayarı lazım.
                    // AddItem metodun "item.Count"u DB'ye yazıyor. O yüzden:

                    // Geçici olarak Count'u ayarla
                    int originalCount = item.Count;
                    item.Count = amountToInsert;

                    bool success = InsertNewItemToDB(item); // Aşağıdaki yardımcı metot

                    // Count'u geri yükle ki döngü hesabımız bozulmasın
                    item.Count = originalCount;

                    if (!success) return false;

                    // Elimizdeki miktarı düş
                    item.Count -= amountToInsert;
                }
            }

            return true; // Hepsi başarıyla dağıtıldı
        }
        private bool InsertNewItemToDB(ItemInstance item)
        {
            using (var conn = DatabaseHelper.GetConnection())
            {
                conn.Open();
                string sql = @"
                INSERT INTO ItemInstances 
                (TemplateID, OwnerID, SlotIndex, Grade, Location, Count, UpgradeLevel) 
                VALUES 
                (@tid, @oid, @slot, @grade, @loc, @count, @upg)";

                SqlCommand cmd = new SqlCommand(sql, conn);
                cmd.Parameters.AddWithValue("@tid", item.TemplateID);
                cmd.Parameters.AddWithValue("@oid", item.OwnerID);
                cmd.Parameters.AddWithValue("@slot", item.SlotIndex);
                cmd.Parameters.AddWithValue("@grade", (byte)item.Grade);
                cmd.Parameters.AddWithValue("@loc", (byte)item.Location);
                cmd.Parameters.AddWithValue("@count", item.Count); // O anki parça sayısı
                cmd.Parameters.AddWithValue("@upg", item.UpgradeLevel);

                return cmd.ExecuteNonQuery() >0;
            }
        }
        // EŞYA BÖLME
        public (bool Success, string Message) SplitItem(ItemInstance item, int amountToSplit)
        {
            if (amountToSplit >= item.Count) return (false, "Hatalı miktar.");
            if (amountToSplit <= 0) return (false, "En az 1 adet bölmelisin.");

            // 1. Boş yer var mı?
            int emptySlot = _repo.FindFirstEmptyInventorySlot(item.OwnerID);
            if (emptySlot == -1) return (false, "Bölmek için boş yer yok!");

            // 2. Yeni parçayı oluştur
            ItemInstance newItem = new ItemInstance
            {
                TemplateID = item.TemplateID,
                OwnerID = item.OwnerID,
                SlotIndex = emptySlot,
                Count = amountToSplit,
                // Diğer özelliklerini kopyala
                Name = item.Name,
                Grade = item.Grade,
                ItemType = item.ItemType,
                IsStackable = item.IsStackable,
                MaxStack = item.MaxStack,
                Location = Core.Enums.ItemLocation.Inventory
            };

            // 3. Veritabanı İşlemleri
            // A. Yeni parçayı kaydet (Mevcut AddItem metodunu kullanabiliriz ama yerini biz belirledik)
            // Direkt INSERT yapalım, helper metodunu kullanabilirsin veya repo çağırabilirsin.
            // Burada AddItemToInventory çağırmıyoruz çünkü o stacklemeye çalışır, biz AYIRMAK istiyoruz.

            // Geçici bir insert metodu veya repository çağrısı:
            // (Not: InventoryRepository'ye InsertItem metodunu public açman gerekebilir veya sql sorgusu yazabilirsin)
            // Şimdilik varsayalım ki repo üzerinden ekliyoruz:
            bool inserted = _repo.AddItemDirectly(newItem); // *Bunu Repo'ya ekleyeceğiz

            if (inserted)
            {
                // B. Eski parçayı azalt
                _repo.ConsumeItem(item.InstanceID, amountToSplit); // Count - amount yapar
                return (true, "Eşya bölündü.");
            }

            return (false, "Veritabanı hatası.");
        }

        // EŞYA BİRLEŞTİRME (Sürükle - Bırak Mantığı)
        public bool MergeItems(ItemInstance sourceItem, ItemInstance targetItem)
        {
            // Temel Kontroller
            if (sourceItem.TemplateID != targetItem.TemplateID) return false; // Aynı eşya değil
            if (!targetItem.IsStackable) return false; // Stacklenemez
            if (targetItem.Count >= targetItem.MaxStack) return false; // Hedef zaten dolu

            // Matematik
            int spaceAvailable = targetItem.MaxStack - targetItem.Count;
            int amountToMove = System.Math.Min(spaceAvailable, sourceItem.Count);

            if (amountToMove <= 0) return false;

            // 1. Hedefi Artır (DB Update)
            bool incSuccess = _repo.IncrementItemCount(targetItem.InstanceID, amountToMove);

            // 2. Kaynağı Azalt (DB Update veya Delete)
            if (incSuccess)
            {
                _repo.ConsumeItem(sourceItem.InstanceID, amountToMove);
                return true;
            }

            return false;
        }
        public int FindFirstEmptyStorageSlot(int characterId)
        {
            // Tüm eşyaları çek
            var allItems = _repo.GetCharacterInventory(characterId);

            // Sadece depodakileri filtrele
            var storageItems = allItems.Where(x => x.Location == Core.Enums.ItemLocation.Storage).ToList();

            // 0'dan 40'a kadar bak, boş olan ilk sayıyı dön
            for (int i = 0; i < 42; i++)
            {
                if (!storageItems.Any(x => x.SlotIndex == i))
                    return i;
            }
            return -1; // Yer yok
        }
        public int FindFirstEmptyInventorySlot(int characterId)
        {
            return _repo.FindFirstEmptyInventorySlot(characterId);
        }
        public List<ItemInstance> GetSharedStorage()
        {
            return _repo.GetSharedStorageItems();
        }
        public bool TransferItem(CharacterModel hero, ItemInstance sourceItem, Enums.ItemLocation targetLoc, int targetSlot)
        {
            // A. Hedef Slotta Eşya Var mı?
            ItemInstance targetItem = null;

            if (targetLoc == Enums.ItemLocation.Inventory)
                targetItem = _repo.GetItemAt(hero.CharacterID, targetLoc, targetSlot);
            else if (targetLoc == Enums.ItemLocation.Storage)
            {
                var allStorage = GetSharedStorage();
                targetItem = allStorage.FirstOrDefault(x => x.SlotIndex == targetSlot);
            }

            // B. HEDEF DOLU İSE -> BİRLEŞTİRME (MERGE) DENEMESİ
            if (targetItem != null)
            {
                // Farklı eşya ise işlem iptal
                if (sourceItem.TemplateID != targetItem.TemplateID) return false;

                // Stacklenemez ise veya hedef zaten tam dolu ise işlem iptal
                if (!targetItem.IsStackable) return false;
                if (targetItem.Count >= targetItem.MaxStack) return false;

                // --- MATEMATİKSEL KISIM ---
                // Hedefte ne kadar boşluk var?
                int spaceAvailable = targetItem.MaxStack - targetItem.Count;

                // Ne kadar taşıyacağız? (Ya boşluk kadar, ya da elimizdeki hepsi)
                int amountToMove = Math.Min(spaceAvailable, sourceItem.Count);

                // Eğer taşınacak miktar yoksa hata dön
                if (amountToMove <= 0) return false;

                // 1. Hedefi Artır (DB Update)
                _repo.IncrementItemCount(targetItem.InstanceID, amountToMove);

                // 2. Kaynağı Azalt (DB Update/Delete)
                // ConsumeItem metodu, miktar 0'a düşerse satırı tamamen siler.
                _repo.ConsumeItem(sourceItem.InstanceID, amountToMove);

                // İşlem başarılı (Kısmi taşıma olsa bile true döneriz, çünkü bir işlem yaptık)
                return true;
            }

            // C. HEDEF BOŞ İSE -> NORMAL TAŞIMA
            // Önce konumu ve slotu güncelle
            _repo.MoveItemLocation(sourceItem.InstanceID, targetLoc, targetSlot);

            // Envantere geçtiyse sahibi değişir (Depodan -> Envantere)
            if (targetLoc == Enums.ItemLocation.Inventory)
            {
                _repo.UpdateItemOwner(sourceItem.InstanceID, hero.CharacterID);
            }

            return true;
        }
        public void SmartWithdraw(CharacterModel hero, ItemInstance sourceItem)
        {
            if (hero == null || sourceItem == null) return;

            // Refresh source from storage to get current DB values
            ItemInstance refreshed = GetSharedStorage().FirstOrDefault(x => x.InstanceID == sourceItem.InstanceID);
            if (refreshed == null) return; // already gone

            //1) First, try to fill existing partial stacks in inventory
            while (true)
            {
                // Refresh source
                refreshed = GetSharedStorage().FirstOrDefault(x => x.InstanceID == sourceItem.InstanceID);
                if (refreshed == null) return; // nothing left

                // Find an inventory stack with capacity
                var existingStack = _repo.FindStackableItemWithCapacity(hero.CharacterID, refreshed.TemplateID, refreshed.MaxStack);
                if (existingStack == null) break; // no partial stacks

                int spaceAvailable = existingStack.MaxStack - existingStack.Count;
                if (spaceAvailable <=0) break;

                int amountToMove = Math.Min(spaceAvailable, refreshed.Count);
                if (amountToMove <=0) break;

                // Perform DB updates: increment inventory stack, reduce storage item
                bool inc = _repo.IncrementItemCount(existingStack.InstanceID, amountToMove);
                if (!inc) break; // DB error

                _repo.ConsumeItem(refreshed.InstanceID, amountToMove);

                // loop to try again until no partial stacks or source depleted
            }

            //2) If still remaining, move into empty inventory slots (may require splitting)
            while (true)
            {
                refreshed = GetSharedStorage().FirstOrDefault(x => x.InstanceID == sourceItem.InstanceID);
                if (refreshed == null) return; // finished

                int remaining = refreshed.Count;
                if (remaining <=0) return;

                int emptySlot = FindFirstEmptyInventorySlot(hero.CharacterID);
                if (emptySlot == -1) return; // no space

                int amountToMove = Math.Min(remaining, refreshed.MaxStack);

                if (amountToMove == remaining)
                {
                    // Move entire DB row from storage to inventory (cheaper)
                    bool moved = _repo.MoveItemLocation(refreshed.InstanceID, Enums.ItemLocation.Inventory, emptySlot);
                    if (moved) _repo.UpdateItemOwner(refreshed.InstanceID, hero.CharacterID);
                    return;
                }
                else
                {
                    // Partial: insert a new inventory row and decrease storage
                    ItemInstance newItem = new ItemInstance
                    {
                        TemplateID = refreshed.TemplateID,
                        OwnerID = hero.CharacterID,
                        SlotIndex = emptySlot,
                        Count = amountToMove,
                        Grade = refreshed.Grade,
                        Location = Enums.ItemLocation.Inventory,
                        ItemType = refreshed.ItemType,
                        IsStackable = refreshed.IsStackable,
                        MaxStack = refreshed.MaxStack,
                        Name = refreshed.Name
                    };

                    bool inserted = _repo.AddItemDirectly(newItem);
                    if (!inserted) return; // DB error

                    // Decrease storage
                    _repo.ConsumeItem(refreshed.InstanceID, amountToMove);
                    // Continue loop in case more remains
                }
            }
        }
    }
}