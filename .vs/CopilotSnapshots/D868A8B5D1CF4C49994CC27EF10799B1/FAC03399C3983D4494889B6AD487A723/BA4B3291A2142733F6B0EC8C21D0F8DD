using rpg_deneme.Business;
using rpg_deneme.Core; // Enums için
using rpg_deneme.Models;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Timer = System.Windows.Forms.Timer;

namespace rpg_deneme.UI.Controls
{
    public partial class UcArena : UserControl
    {
        private ArenaPanel _arena;
        private Timer _gameLoop;

        // Hotbar
        private class HotbarSlot
        {
            public int Index { get; set; }
            public long? InstanceID { get; set; }
            public ItemInstance Item { get; set; }
        }
        private List<HotbarSlot> _hotbar = new List<HotbarSlot>();

        // Varlıklar
        private BattleEntity _player;

        // DÜZELTME: Tekil _enemy yerine sadece liste kullanıyoruz.
        // Zone sistemi tek düşman gönderdiğinde bu listeye 1 tane ekleyeceğiz.
        private List<BattleEntity> _enemies = new List<BattleEntity>();

        private List<Projectile> _projectiles = new List<Projectile>();
        private CharacterModel _hero;

        private InventoryManager _invManager = new InventoryManager();

        private Button _btnMap;
        public event EventHandler OnMapRequested;

        // Klavye & Mouse
        private bool _w, _a, _s, _d;
        private Point _mousePos = Point.Empty;

        // Eventler
        public event EventHandler<bool> OnBattleEnded;
        public event EventHandler OnStatsUpdated;

        private int _attackDelayMs = 1000;
        private DateTime _lastAttackTime = DateTime.MinValue;
        private int _manaCostPerHit = 0;

        private bool _isTownMode = false;
        private List<NpcEntity> _npcs = new List<NpcEntity>();
        public event EventHandler<NpcEntity> OnNpcInteraction;

        private bool _isBattleEnding = false;

        private List<VisualEffect> _effects = new List<VisualEffect>();
        private ToolTip _hotbarTooltip = new ToolTip();

        private int _enemyAttackCooldown = 0;

        public UcArena()
        {
            this.DoubleBuffered = true;
            this.BackColor = Color.Black;
            SetupArena();
        }

        private void SetupArena()
        {
            _arena = new ArenaPanel();
            _arena.Dock = DockStyle.Fill;
            _arena.BackColor = Color.FromArgb(45, 45, 48);
            _arena.Paint += Arena_Paint;
            _arena.MouseDown += Arena_MouseDown;
            _arena.MouseMove += (s, e) => { _mousePos = e.Location; HandleHotbarHover(e.Location); };

            _arena.AllowDrop = true;
            _arena.DragEnter += Arena_DragEnter;
            _arena.DragDrop += Arena_DragDrop;

            this.Controls.Add(_arena);
            this.Click += (s, e) => this.Focus();

            for (int i = 0; i < 5; i++) _hotbar.Add(new HotbarSlot { Index = i });
        }

        private void HandleHotbarHover(Point clientPt)
        {
            // Show tooltip when hovering over a hotbar slot
            for (int i =0; i < _hotbar.Count; i++)
            {
                var rect = GetHotbarSlotRect(i);
                if (rect.Contains(clientPt) && _hotbar[i].Item != null)
                {
                    // Use UcItemSlot.GetTooltipText by instantiating a temporary slot
                    var temp = new UcItemSlot(0);
                    string tt = temp.GetTooltipText(_hotbar[i].Item);
                    _hotbarTooltip.Show(tt, _arena, rect.Right +10, rect.Top);
                    return;
                }
            }
            _hotbarTooltip.Hide(_arena);
        }

        private void LoadHotbarFromSession()
        {
            for (int i = 0; i < 5; i++)
            {
                // Try to load from SessionManager first (in-game cache)
                var id = Core.SessionManager.HotbarSlots[i];
                if (id.HasValue)
                {
                    int ownerId = _hero != null ? _hero.CharacterID : (Core.SessionManager.CurrentCharacter?.CharacterID ?? 0);
                    if (ownerId > 0)
                    {
                        var inv = _invManager.GetInventory(ownerId);
                        var it = inv.FirstOrDefault(x => x.InstanceID == id.Value);
                        if (it != null)
                        {
                            _hotbar[i].InstanceID = id.Value;
                            _hotbar[i].Item = it;
                            continue;
                        }
                    }
                }
                _hotbar[i].InstanceID = null;
                _hotbar[i].Item = null;
            }
        }

        private void SaveHotbarToSession()
        {
            if (_hero == null) return;
            // Save to session (in-memory cache)
            for (int i = 0; i < 5; i++)
                Core.SessionManager.HotbarSlots[i] = _hotbar[i].InstanceID;
            
   // TODO: Optionally persist to database if needed:
        // var charRepo = new CharacterRepository();
       // charRepo.SaveHotbar(_hero.CharacterID, _hotbar.Select(h => h.InstanceID).ToArray());
  }

        // --- ZONE SİSTEMİ İÇİN OLAN ESKİ BAŞLATMA METODU (GÜNCELLENDİ) ---
        // Bu metod artık tek düşmanı listeye ekleyerek çalışıyor.
        // Zone sistemini BOZMAZ.
        public void StartBattle(CharacterModel hero, BattleEntity enemyTemplate)
        {
            PrepareBattleCommon(hero); // Ortak hazırlıklar

            // Tekil düşmanı oluşturup listeye atıyoruz
            var singleEnemy = new BattleEntity
            {
                X = this.Width - 100,
                Y = this.Height / 2 - 20,
                Width = enemyTemplate.Width,
                Height = enemyTemplate.Height,
                Speed = enemyTemplate.Speed,
                MaxHP = enemyTemplate.MaxHP,
                CurrentHP = enemyTemplate.MaxHP,
                Damage = enemyTemplate.Damage,
                Name = enemyTemplate.Name,
                IsRanged = enemyTemplate.IsRanged,
                AttackRange = enemyTemplate.AttackRange
            };

            _enemies.Clear(); // Önce temizle
            _enemies.Add(singleEnemy); // Listeye ekle

            StartGameLoop();
        }
        // --- SURVIVAL MODU İÇİN BAŞLATMA METODU ---
        public void StartSurvivalBattle(CharacterModel hero, List<EnemyModel> enemyTemplates)
        {
            PrepareBattleCommon(hero);

            var (w, h) = GetArenaSize();
            Random rnd = new Random();
            // Listeden gelen tüm düşmanları oluştur
            foreach (var tmpl in enemyTemplates)
            {
                // Rastgele konum (Ekranın sağına dağıt)
                int ex = w - 100 - rnd.Next(0, 200);
                int ey = 100 + rnd.Next(0, Math.Max(100, h - 200));

                // Determine ranged flag using the template metadata (prefer explicit flags over SpritePath parsing)
                bool isRangedUnit = tmpl.IsRanged || tmpl.Type == Enums.EnemyType.Ranged;
                // Fallback: if template AttackRange is set use it; otherwise use default values
                int attackRange = tmpl.AttackRange >0 ? tmpl.AttackRange : (isRangedUnit ?250 :50);

                var newEnemy = new BattleEntity
                {
                    X = ex,
                    Y = ey,
                    Width = tmpl.Width,
                    Height = tmpl.Height,
                    Speed = tmpl.Speed,
                    MaxHP = tmpl.MaxHP,
                    CurrentHP = tmpl.MaxHP,
                    Damage = tmpl.Damage,
                    Name = tmpl.Name, // İsim etiketi için

                    // Menzil Ayarları
                    IsRanged = isRangedUnit,
                    AttackRange = attackRange
                };
                _enemies.Add(newEnemy);
            }

            StartGameLoop();
        }
        private void PrepareBattleCommon(CharacterModel hero)
        {
            _hero = hero;
            LoadHotbarFromSession();
            _projectiles.Clear();
            _enemies.Clear(); // Listeyi temizle
            _w = _a = _s = _d = false;
            _isBattleEnding = false;
            _isTownMode = false;

            // Player Stat Hesaplama
            var inventory = _invManager.GetInventory(hero.CharacterID);
            var equippedWeapon = inventory.FirstOrDefault(x => x.Location == Enums.ItemLocation.Equipment && x.ItemType == Enums.ItemType.Weapon);
            var equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();

            int calculatedDamage = (_hero.Class == (byte)Enums.CharacterClass.Mage)
                ? StatManager.CalculateMagicalDamage(_hero, equippedWeapon)
                : StatManager.CalculatePhysicalDamage(_hero, equippedWeapon);

            int calculatedDefense = StatManager.CalculateTotalDefense(_hero, equippedItems);
            float attackSpeed = StatManager.CalculateAttackSpeed(hero, equippedWeapon);
            _attackDelayMs = (int)(1000f / attackSpeed);
            _manaCostPerHit = StatManager.CalculateAttackManaCost(hero);
            int maxHp = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);

            int startX = this.Width / 2 - 16;
            int startY = this.Height / 2 - 16;

            _player = new BattleEntity { X = startX, Y = startY, Width = 32, Height = 32, Speed = 5.0f, MaxHP = maxHp, CurrentHP = _hero.HP, Damage = calculatedDamage, Defense = calculatedDefense };
            if (_player.CurrentHP > _player.MaxHP) _player.CurrentHP = _player.MaxHP;
        }
        private void StartGameLoop()
        {
            if (_gameLoop == null)
            {
                _gameLoop = new Timer { Interval = 16 };
                _gameLoop.Tick += GameTick;
            }
            _gameLoop.Start();
            this.Focus();
        }
        public void HandleKeyDown(Keys key)
        {
            // 1. Hareket tuşlarını ayarla
            SetKey(key, true);

            // 2. Hotbar tuşlarını kontrol et (DÜZELTME BURASI)
            // UcExploration üzerinden gelen tuşlar artık buraya düşecek.
            HandleHotbarKey(key);
        }
        public void HandleKeyUp(Keys key) { SetKey(key, false); }

        // Accept numeric keys for hotbar (1-5)
        public void HandleHotbarKey(Keys key)
        {
            int index = -1;
            if (key >= Keys.D1 && key <= Keys.D5) index = key - Keys.D1;
            else if (key >= Keys.NumPad1 && key <= Keys.NumPad5) index = key - Keys.NumPad1;
            if (index >=0) UseHotbarSlot(index);
        }

        private void SetKey(Keys key, bool pressed)
        {
            if (key == Keys.W) _w = pressed;
            if (key == Keys.S) _s = pressed;
            if (key == Keys.A) _a = pressed;
            if (key == Keys.D) _d = pressed;
        }
        private void GameTick(object sender, EventArgs e)
        {
            if (_player == null) return;

            if (_isBattleEnding)
            {
                UpdateEffects();
                _arena.Invalidate();
                return;
            }
            if (_hero != null)
            {
                _player.CurrentHP = _hero.HP;
                _player.MaxHP = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level); // Buff gelirse MaxHP de değişebilir
                                                                                    // Mana barı çiziyorsan onu da ekleyebilirsin, ama genelde player üzerinde sadece HP olur.
            }
            UpdatePlayer();
            UpdateProjectiles();
            UpdateEffects();
            UpdateHotbarState; // Bu metod sende var, aynen kalsın

            // DÜZELTME: Tekli UpdateEnemy yerine çoğul UpdateEnemies
            if (!_isTownMode)
            {
                UpdateEnemies();
            }

            _arena.Invalidate();
        }

        private void UpdateHotbarState()
        {
            if (_hero == null) return;
            var inv = _invManager.GetInventory(_hero.CharacterID);
            for (int i =0; i < _hotbar.Count; i++)
            {
                var slot = _hotbar[i];
                if (slot.InstanceID.HasValue)
                {
                    var it = inv.FirstOrDefault(x => x.InstanceID == slot.InstanceID.Value);
                    if (it == null)
                    {
                        slot.InstanceID = null;
                        slot.Item = null;
                    }
                    else
                    {
                        slot.Item = it;
                    }
                }
            }
        }

        private void UpdatePlayer()
        {
            float proposedX = _player.X;
            float proposedY = _player.Y;

            if (_w && _player.Y >0) proposedY -= _player.Speed;
            if (_s && _player.Y < _arena.Height - _player.Height) proposedY += _player.Speed;
            if (_a && _player.X >0) proposedX -= _player.Speed;
            if (_d && _player.X < _arena.Width - _player.Width) proposedX += _player.Speed;

            var proposedRect = new Rectangle((int)proposedX, (int)proposedY, _player.Width, _player.Height);
            bool collides = false;

            if (_isTownMode)
            {
                foreach (var npc in _npcs)
                {
                    var npcRect = new Rectangle((int)npc.X, (int)npc.Y, npc.Width, npc.Height);
                    if (proposedRect.IntersectsWith(npcRect)) { collides = true; break; }
                }
            }
            else
            {
                foreach (var en in _enemies)
                {
                    if (en.CurrentHP > 0)
                    {
                        var enemyRect = new Rectangle((int)en.X, (int)en.Y, en.Width, en.Height);
                        if (proposedRect.IntersectsWith(enemyRect)) { collides = true; break; }
                    }
                }
            }

            if (!collides)
            {
                _player.X = proposedX;
                _player.Y = proposedY;
            }
        }

        private void UpdateEnemies()
        {
            if (_enemyAttackCooldown > 0) _enemyAttackCooldown--;

            int aliveCount = 0;

            // Düşman listesinin kopyasını almayalım ama iç içe döngü için indeksli erişim yapalım
            for (int i = 0; i < _enemies.Count; i++)
            {
                var enemy = _enemies[i];
                if (enemy.CurrentHP <= 0) continue;
                aliveCount++;

                // 1. OYUNCUYA OLAN MESAFE VE YÖN
                float distToPlayer = Distance(enemy.Center.X, enemy.Center.Y, _player.Center.X, _player.Center.Y);
                float dx = _player.X - enemy.X;
                float dy = _player.Y - enemy.Y;

                // Normalize edilmiş yön vektörü (Oyuncuya doğru)
                float dirX = (distToPlayer > 0) ? dx / distToPlayer : 0;
                float dirY = (distToPlayer > 0) ? dy / distToPlayer : 0;

                // 2. SEPARATION (BİRBİRİNİ İTME MANTIĞI)
                // Düşmanların iç içe geçmesini önlemek için "Boid Separation"
                float sepX = 0, sepY = 0;
                int neighbors = 0;

                foreach (var other in _enemies)
                {
                    if (other == enemy || other.CurrentHP <= 0) continue;

                    float distToOther = Distance(enemy.Center.X, enemy.Center.Y, other.Center.X, other.Center.Y);

                    // Eğer çok yakınsa (örn: 40 piksel), zıt yöne itme kuvveti uygula
                    if (distToOther < 40)
                    {
                        sepX += (enemy.X - other.X) / distToOther; // Uzaklaşma vektörü
                        sepY += (enemy.Y - other.Y) / distToOther;
                        neighbors++;
                    }
                }

                // İtme kuvvetini uygula (Sürü davranışı)
                if (neighbors > 0)
                {
                    // İtme gücü katsayısı (1.5f = ne kadar sert itecekleri)
                    dirX += (sepX / neighbors) * 1.5f;
                    dirY += (sepY / neighbors) * 1.5f;
                }

                // 3. HAREKET KARARI (MELEE vs RANGED)
                float desiredRange = enemy.IsRanged ? 250f : 40f; // Uzakçı 250 birim ötede durur
                bool shouldMove = true;

                if (enemy.IsRanged)
                {
                    // RANGED MANTIĞI
                    if (distToPlayer <= desiredRange && distToPlayer > desiredRange * 0.6f)
                    {
                        shouldMove = false; // İdeal menzilde, dur ve ateş et
                    }
                    else if (distToPlayer <= desiredRange * 0.6f)
                    {
                        // Çok yaklaştı, geri kaç (Kiting)
                        dirX = -dirX;
                        dirY = -dirY;
                    }
                }
                else
                {
                    // MELEE MANTIĞI
                    // Saldırı menziline girdiyse dur ve vur
                    if (distToPlayer <= desiredRange) shouldMove = false;
                }

                // Hareketi Uygula
                if (shouldMove)
                {
                    enemy.X += dirX * enemy.Speed;
                    enemy.Y += dirY * enemy.Speed;
                }

                // 4. SALDIRI MANTIĞI
                // Her düşmanın kendi attack timer'ı olmalı aslında ama şimdilik basitleştirilmiş bir random/timer yapısı kuralım.
                // Menzilliler için Mermi Atma
                if (enemy.IsRanged && distToPlayer <= desiredRange + 50)
                {
                    // Basit bir ateş etme oranı (%2 şans her frame, yaklaşık saniyede 1-2 atış)
                    Random rnd = new Random(i + DateTime.Now.Millisecond); // Seed varyasyonu
                    if (rnd.Next(0, 100) < 2)
                    {
                        // Düşman mermisi oluştur
                        var proj = new Projectile(enemy.Center.X, enemy.Center.Y, _player.Center.X, _player.Center.Y, enemy.Damage, true);
                        // Rengi farklı olsun (Paint metodunda halledeceğiz)
                        _projectiles.Add(proj);
                    }
                }
                // Yakıncılar için Vuruş (Mevcut mantık)
                else if (!enemy.IsRanged && distToPlayer <= 50) // Melee range
                {
                    if (_enemyAttackCooldown <= 0)
                    {
                        ApplyDamageToPlayer(enemy.Damage);
                        _enemyAttackCooldown = 60; // Global immunity frame

                        // Knockback (Sadece yakın vuruşta itme olur)
                        _player.X += (dx / distToPlayer) * 50; // Tersi yönde it
                        _player.Y += (dy / distToPlayer) * 50;
                        ClampEntityPosition(_player);
                    }
                }

                ClampEntityPosition(enemy);
            }

            if (aliveCount == 0 && !_isBattleEnding) StartBattleEndSequence(true);
        }

        private void ApplyDamageToPlayer(int incomingDamage)
        {
            if (_isBattleEnding) return;
            int reducedDamage = incomingDamage - _player.Defense;
            if (reducedDamage <1) reducedDamage =1;
            _player.CurrentHP -= reducedDamage;
            _hero.HP = _player.CurrentHP;
            OnStatsUpdated?.Invoke(this, EventArgs.Empty);
            if (_player.CurrentHP <=0)
            {
                _player.CurrentHP =0;
                StartBattleEndSequence(false);
            }
        }

        private void UpdateProjectiles()
        {
            for (int i = _projectiles.Count - 1; i >= 0; i--)
            {
                var proj = _projectiles[i];
                proj.Move();

                // Ekran dışı kontrolü
                if (proj.X < 0 || proj.X > _arena.Width || proj.Y < 0 || proj.Y > _arena.Height)
                {
                    _projectiles.RemoveAt(i);
                    continue;
                }

                bool hit = false;

                if (proj.IsEnemy) // Düşman mermisi -> Oyuncuya çarpar
                {
                    if (_player.Bounds.IntersectsWith(proj.Bounds))
                    {
                        ApplyDamageToPlayer(proj.Damage);
                        hit = true;
                    }
                }
                else // Oyuncu mermisi -> Düşmanlara çarpar
                {
                    foreach (var en in _enemies)
                    {
                        if (en.CurrentHP > 0 && proj.Bounds.IntersectsWith(en.Bounds))
                        {
                            ApplyDamageToEnemy(en, proj.Damage);
                            hit = true;
                            break;
                        }
                    }
                }

                if (hit) _projectiles.RemoveAt(i);
            }
        }

        private void ApplyDamageToEnemy(BattleEntity targetEnemy, int dmg)
        {
            targetEnemy.CurrentHP -= dmg;
            _effects.Add(new VisualEffect { X = targetEnemy.X + 10, Y = targetEnemy.Y, Text = $"-{dmg}", Color = Color.Yellow, IsText = true, LifeTime = 30 });

            // Ölüm kontrolü UpdateEnemies içinde yapılıyor (aliveCount)
            // Ama anlık kontrol için HP < 0 düzeltmesi:
            if (targetEnemy.CurrentHP < 0) targetEnemy.CurrentHP = 0;
        }

        private void Arena_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(typeof(ItemInstance)))
            {
                var item = (ItemInstance)e.Data.GetData(typeof(ItemInstance));
                if (item != null && item.ItemType == Enums.ItemType.Consumable) { e.Effect = DragDropEffects.Move; return; }
            }
            e.Effect = DragDropEffects.None;
        }

        private void Arena_DragDrop(object sender, DragEventArgs e)
        {
            if (!e.Data.GetDataPresent(typeof(ItemInstance))) return;
            var item = (ItemInstance)e.Data.GetData(typeof(ItemInstance));
            var pt = _arena.PointToClient(new Point(e.X, e.Y));
            for (int i =0; i <5; i++)
            {
                var rect = GetHotbarSlotRect(i);
                if (rect.Contains(pt))
                {
                    _hotbar[i].InstanceID = item.InstanceID;
                    _hotbar[i].Item = item;
                    SaveHotbarToSession();
                    break;
                }
            }
        }

        private Rectangle GetHotbarSlotRect(int index)
        {
            int slotSize =56;
            int gap =8;
            int totalWidth = slotSize *5 + gap *4;
            int startX = (_arena.Width - totalWidth) /2;
            int y = _arena.Height - slotSize -10;
            int x = startX + index * (slotSize + gap);
            return new Rectangle(x, y, slotSize, slotSize);
        }
        private void Arena_MouseDown(object sender, MouseEventArgs e)
        {
            if (_hero == null || _player == null || _isBattleEnding) return;
            if (_isBattleEnding) return;

            // Hotbar Interaction (Aynı kalıyor)
            for (int i = 0; i < _hotbar.Count; i++)
            {
                var rect = GetHotbarSlotRect(i);
                if (rect.Contains(e.Location))
                {
                    if (e.Button == MouseButtons.Left) { _hotbar[i].InstanceID = null; _hotbar[i].Item = null; SaveHotbarToSession(); return; }
                    else if (e.Button == MouseButtons.Right) { UseHotbarSlot(i); return; }
                }
            }

            // Attack Logic
            if (e.Button == MouseButtons.Left)
            {
                if ((DateTime.Now - _lastAttackTime).TotalMilliseconds < _attackDelayMs) return;
                if (_hero.Mana < _manaCostPerHit) { if (!_isTownMode) { if (_hero.Mana < _manaCostPerHit) return; _hero.Mana -= _manaCostPerHit; } return; }

                _hero.Mana -= _manaCostPerHit;
                _lastAttackTime = DateTime.Now;
                OnStatsUpdated?.Invoke(this, EventArgs.Empty);

                if (_hero.Class == (byte)Enums.CharacterClass.Mage)
                {
                    // DÜZELTME: En sona 'false' eklendi. (false = Düşman değil, Oyuncu mermisi)
                    var proj = new Projectile(_player.Center.X, _player.Center.Y, e.X, e.Y, _player.Damage, false);
                    _projectiles.Add(proj);
                }
                else
                {
                    // WARRIOR/ROGUE: Yakın Dövüş
                    _effects.Add(new VisualEffect { X = e.X - 10, Y = e.Y - 10, Color = Color.WhiteSmoke, IsText = false, Size = 20, LifeTime = 10 });

                    if (!_isTownMode)
                    {
                        // DÜZELTME: Tıklanan noktadaki veya en yakın düşmanı bul
                        BattleEntity target = null;

                        // Önce tam tıklanan yerde düşman var mı?
                        foreach (var en in _enemies)
                        {
                            if (en.CurrentHP > 0 && en.Bounds.Contains(e.Location))
                            {
                                target = en;
                                break;
                            }
                        }

                        // Yoksa, menzil içindeki en yakın düşmanı bul (Kolaylık olsun diye)
                        if (target == null)
                        {
                            foreach (var en in _enemies)
                            {
                                if (en.CurrentHP <= 0) continue;
                                float dist = Distance(_player.Center.X, _player.Center.Y, en.Center.X, en.Center.Y);
                                if (dist < 80f) // Menzil
                                {
                                    target = en;
                                    break;
                                }
                            }
                        }

                        if (target != null)
                        {
                            float dist = Distance(_player.Center.X, _player.Center.Y, target.Center.X, target.Center.Y);

                            // Karakterin silah menzili (Warrior/Rogue için genelde 60-80px)
                            float meleeRange = 80f;

                            if (dist <= meleeRange)
                            {
                                ApplyDamageToEnemy(target, _player.Damage);
                                _effects.Add(new VisualEffect { X = e.X, Y = e.Y, Color = Color.Red, IsText = false, Size = 10, LifeTime = 15 });
                            }
                        }
                    }
                }
            }
            // NPC Interaction (Aynı kalıyor)
            if (_isTownMode && e.Button == MouseButtons.Right)
            {
                foreach (var npc in _npcs)
                {
                    float mouseDist = Distance(e.X, e.Y, npc.X + npc.Width / 2, npc.Y + npc.Height / 2);
                    if (mouseDist < 60)
                    {
                        float playerDist = Distance(_player.Center.X, _player.Center.Y, npc.X + npc.Width / 2, npc.Y + npc.Height / 2);
                        if (playerDist < 150) OnNpcInteraction?.Invoke(this, npc);
                        else MessageBox.Show("Sesini duyuramıyorum, biraz daha yaklaş! (WASD ile yürü)");
                        return;
                    }
                }
            }
        }

        private void UseHotbarSlot(int index)
        {
            if (index <0 || index >= _hotbar.Count) return;
            var slot = _hotbar[index];
            if (slot.InstanceID == null) return;
            if (_hero == null) return;

            var inv = _invManager.GetInventory(_hero.CharacterID);
            var item = inv.FirstOrDefault(x => x.InstanceID == slot.InstanceID.Value);
            if (item == null)
            {
                slot.InstanceID = null; slot.Item = null; SaveHotbarToSession(); return;
            }

            if (item.RemainingCooldownSeconds >0) return;

            var cm = new ConsumableManager();
            var res = cm.UseItem(Core.SessionManager.CurrentCharacter, item);
            if (res.Success)
            {
                var inv2 = _invManager.GetInventory(_hero.CharacterID);
                var it2 = inv2.FirstOrDefault(x => x.InstanceID == slot.InstanceID.Value);
                if (it2 == null) { slot.InstanceID = null; slot.Item = null; }
                else { slot.Item = it2; }
                OnStatsUpdated?.Invoke(this, EventArgs.Empty);
                SaveHotbarToSession();
                // Refresh main UI
                if (this.ParentForm is FormMain main) main.RefreshStats();
            }
        }

        private void Arena_Paint(object sender, PaintEventArgs e)
        {
            if (_player == null) return;
            Graphics g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

            // Player Çizimi (Aynı)
            Brush playerColor = _hero != null && _hero.Class == (byte)Enums.CharacterClass.Mage ? Brushes.CornflowerBlue : Brushes.DarkOrange;
            g.FillRectangle(playerColor, _player.X, _player.Y, _player.Width, _player.Height);
            if (_player.MaxHP > 0)
            {
                float playerHpPct = (float)_player.CurrentHP / _player.MaxHP;
                g.FillRectangle(Brushes.Red, _player.X, _player.Y - 10, _player.Width, 5);
                g.FillRectangle(Brushes.Lime, _player.X, _player.Y - 10, _player.Width * playerHpPct, 5);
            }

            // Projectiles
            foreach (var proj in _projectiles)
            {
                Brush b = proj.IsEnemy ? Brushes.Violet : Brushes.Cyan; // Düşman mor, biz mavi
                g.FillEllipse(b, proj.X, proj.Y, proj.Size, proj.Size);
            }

            // NPCs
            if (_isTownMode)
            {
                // ... (NPC Çizim Kodu Aynı) ...
                using (Font font = new Font("Segoe UI", 8, FontStyle.Bold))
                using (Brush textBrush = new SolidBrush(Color.White))
                {
                    foreach (var npc in _npcs)
                    {
                        using (Brush b = new SolidBrush(npc.Color)) g.FillRectangle(b, npc.X, npc.Y, npc.Width, npc.Height);
                        SizeF size = g.MeasureString(npc.Name, font);
                        float txtX = npc.X + (npc.Width - size.Width) / 2;
                        g.DrawString(npc.Name, font, textBrush, txtX, npc.Y - 15);
                    }
                }
            }

            //Tüm Düşmanları Çiz
            if (!_isTownMode)
            {
                foreach (var en in _enemies)
                {
                    DrawEnemy(g, en);
                }
            }

            // Effects & Hotbar (Aynı)
            foreach (var fx in _effects)
            {
                if (fx.IsText)
                {
                    using (Font f = new Font("Segoe UI", 12, FontStyle.Bold))
                    {
                        e.Graphics.DrawString(fx.Text, f, Brushes.Black, fx.X + 1, fx.Y + 1);
                        using (Brush b = new SolidBrush(fx.Color)) e.Graphics.DrawString(fx.Text, f, b, fx.X, fx.Y);
                    }
                }
                else
                {
                    using (Pen p = new Pen(fx.Color, 3))
                    {
                        e.Graphics.DrawLine(p, fx.X, fx.Y, fx.X + fx.Size, fx.Y + fx.Size);
                        e.Graphics.DrawLine(p, fx.X + fx.Size, fx.Y, fx.X, fx.Y + fx.Size);
                    }
                }
            }
            DrawHotbar(g);
        }

        private void DrawHotbar(Graphics g)
        {
            for (int i =0; i < _hotbar.Count; i++)
            {
                var rect = GetHotbarSlotRect(i);
                using (Brush b = new SolidBrush(Color.FromArgb(50,50,50)))
                using (Pen p = new Pen(Color.DimGray)) { g.FillRectangle(b, rect); g.DrawRectangle(p, rect); }

                var slot = _hotbar[i];
                if (slot.InstanceID.HasValue && slot.Item != null)
                {
                    var color = GetHotbarColor(slot.Item.Grade, slot.Item.ItemType);
                    Rectangle inner = new Rectangle(rect.X +4, rect.Y +4, rect.Width -8, rect.Height -8);
                    using (Brush ib = new SolidBrush(color)) g.FillRectangle(ib, inner);

                    // Hover name
                    if (rect.Contains(_mousePos))
                    {
                        using (Font f = new Font("Segoe UI",8))
                        using (Brush fb = new SolidBrush(Color.White)) g.DrawString(slot.Item.Name, f, fb, rect.X, rect.Y -16);
                    }

                    if (slot.Item.IsStackable && slot.Item.Count >1)
                    {
                        using (Font f = new Font("Segoe UI",9, FontStyle.Bold))
                        using (Brush fb = new SolidBrush(Color.White))
                        {
                            string txt = slot.Item.Count.ToString();
                            var sz = g.MeasureString(txt, f);
                            g.DrawString(txt, f, fb, rect.Right - sz.Width -6, rect.Bottom - sz.Height -6);
                        }
                    }

                    int rem = slot.Item.RemainingCooldownSeconds;
                    int cd = slot.Item.Cooldown;
                    if (cd >0 && rem >0)
                    {
                        float frac = Math.Max(0f, Math.Min(1f, (float)rem / cd));
                        using (Brush cb = new SolidBrush(Color.FromArgb(180, Color.Black)))
                        {
                            int pad =6;
                            Rectangle pieRect = new Rectangle(rect.X + pad, rect.Y + pad, rect.Width - pad *2, rect.Height - pad *2);
                            float sweep =360f * frac;
                            g.FillPie(cb, pieRect, -90, sweep);
                        }
                        using (Font f = new Font("Segoe UI",10, FontStyle.Bold))
                        using (Brush fb = new SolidBrush(Color.White))
                        {
                            string s = rem.ToString();
                            var sz = g.MeasureString(s, f);
                            g.DrawString(s, f, fb, rect.X + (rect.Width - sz.Width) /2, rect.Y + (rect.Height - sz.Height) /2);
                        }
                    }
                }
                else
                {
                    using (Font f = new Font("Segoe UI",9, FontStyle.Regular))
                    using (Brush fb = new SolidBrush(Color.Gray))
                    {
                        string s = (i +1).ToString();
                        var sz = g.MeasureString(s, f);
                        g.DrawString(s, f, fb, rect.X +6, rect.Y +6);
                    }
                }
            }
        }

        private Color GetHotbarColor(Enums.ItemGrade grade, Enums.ItemType itemType)
        {
            if (itemType == Enums.ItemType.Consumable) return Color.MediumSeaGreen;
            return grade switch
            {
                Enums.ItemGrade.Common => Color.WhiteSmoke,
                Enums.ItemGrade.Rare => Color.CornflowerBlue,
                Enums.ItemGrade.Epic => Color.MediumPurple,
                Enums.ItemGrade.Legendary => Color.Orange,
                _ => Color.Gray,
            };
        }

        public void StartTown(CharacterModel hero)
        {
            _isBattleEnding = false;
            _hero = hero;

            LoadHotbarFromSession();
            _isTownMode = true;
            _projectiles.Clear();
            _enemies.Clear();

            _w = _a = _s = _d = false;
            InitTownEntities();
            UpdateTownLayout();

            // Defer precise layout to OnParentChanged/OnResize where sizes are available
            // Set a reasonable player placeholder; final position will be corrected later
            var (w, h) = GetArenaSize();
            int maxHp = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);
            _player = new BattleEntity { X = w /2 -16, Y = h /2 -16, Width =32, Height =32, Speed =5.0f, MaxHP = maxHp, CurrentHP = _hero.HP, Damage =0, Defense =0 };
            
            if (_gameLoop == null) { _gameLoop = new Timer { Interval =16 }; _gameLoop.Tick += GameTick; }
            _gameLoop.Start();
            this.Focus();
        }

        protected override void OnParentChanged(EventArgs e)
        {
            base.OnParentChanged(e);
            // When the control is added to the form, ensure layout (positions) are recalculated
            if (this.Parent != null && _isTownMode)
            {
                // Recalculate sizes/positions now that we have a parent and real sizes
                var (w, h) = GetArenaSize();
                // center player
                if (_player != null)
                {
                    _player.X = w /2 - _player.Width /2;
                    _player.Y = h /2 - _player.Height /2;
                }
                UpdateTownLayout();
                // reload hotbar based on real owner id
                LoadHotbarFromSession();
                this.Invalidate();
            }
            // If entering battle mode, ensure player/enemy reposition too
            if (this.Parent != null && !_isTownMode)
            {
                var (w, h) = GetArenaSize();
                if (_player != null)
                {
                    _player.X = w /2 - _player.Width /2;
                    _player.Y = h /2 - _player.Height /2;
                }
                Random rnd = new Random();
                foreach (var en in _enemies)
                {
                    // Eğer ekran dışındalarsa veya yeniden boyutlandırma olduysa içeri al
                    if (en.X > w) en.X = w - 100 - rnd.Next(0, 50);
                    if (en.Y > h) en.Y = h / 2;
                }
                this.Invalidate();
            }
        }

        // Savaş sırasında statları güncelleyen kritik metod
        public void RecalculatePlayerStats()
        {
            if (_hero == null || _player == null) return;
            var inventory = _invManager.GetInventory(_hero.CharacterID);
            var equippedWeapon = inventory.FirstOrDefault(x => x.Location == Enums.ItemLocation.Equipment && x.ItemType == Enums.ItemType.Weapon);
            var equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();
            int newDamage = _hero.Class == (byte)Enums.CharacterClass.Mage ? StatManager.CalculateMagicalDamage(_hero, equippedWeapon) : StatManager.CalculatePhysicalDamage(_hero, equippedWeapon);
            int newDefense = StatManager.CalculateTotalDefense(_hero, equippedItems);
            _player.Damage = newDamage;
            _player.Defense = newDefense;
        }

        private void InitTownEntities()
        {
            _npcs.Clear();
            _npcs.Add(new NpcEntity("MARKET", Enums.NpcType.Merchant,0,0));
            _npcs.Add(new NpcEntity("IŞINLAYICI", Enums.NpcType.Teleporter,0,0));
            _npcs.Add(new NpcEntity("DEPOCU", Enums.NpcType.StorageKeeper, 0, 0) { Color = Color.Brown });
            _npcs.Add(new NpcEntity("DEMİRCİ", Enums.NpcType.BlackSmith, 0, 0) { Color = Color.DarkSlateGray });
            _npcs.Add(new NpcEntity("ARENA GUARD", Enums.NpcType.ArenaMaster, 0, 0) { Color = Color.Red });
        }

        private void UpdateTownLayout()
        {
            if (!_isTownMode) return;
            var (w, h) = GetArenaSize();

            // Dikey eksende hizalama
            int centerY = h / 2 - 20;

            // Yatay eksenler
            int leftX = w / 4 - 40;
            int rightX = (w * 3 / 4) - 40;
            int centerX = w / 2 - 20;

            foreach (var npc in _npcs)
            {
                // Enum'a göre veya isme göre konumlandır
                if (npc.Type == Enums.NpcType.Merchant) { npc.X = leftX; npc.Y = centerY; }
                else if (npc.Type == Enums.NpcType.Teleporter) { npc.X = rightX; npc.Y = centerY; }
                else if (npc.Name == "DEPOCU") { npc.X = centerX; npc.Y = centerY - 150; } // Yukarıda
                else if (npc.Name == "DEMİRCİ") { npc.X = centerX; npc.Y = centerY + 150; } // Aşağıda

                // YENİ: Arena Guard (Sağ Alt Çapraz veya Teleporter yanı)
                else if (npc.Name == "ARENA GUARD")
                {
                    npc.X = rightX;
                    npc.Y = centerY + 120; // Işınlayıcının altında
                }
            }

            if (_btnMap != null) _btnMap.Location = new Point(w - 180, 20);
        }

        private (int w, int h) GetArenaSize()
        {
            int w = _arena?.ClientSize.Width ?? this.ClientSize.Width;
            int h = _arena?.ClientSize.Height ?? this.ClientSize.Height;
            if (w <=0 || h <=0)
            {
                if (this.Parent != null)
                {
                    w = this.Parent.ClientSize.Width;
                    h = this.Parent.ClientSize.Height;
                }
            }
            if (w <=0) w =1024;
            if (h <=0) h =720;
            return (w, h);
        }

        // "async" ekledik
        private async void StartBattleEndSequence(bool victory)
        {
            _isBattleEnding = true;
            await System.Threading.Tasks.Task.Delay(1000);
            _gameLoop.Stop();
            _isBattleEnding = false;
            OnBattleEnded?.Invoke(this, victory);
        }

        public class VisualEffect
        {
            public float X { get; set; }
            public float Y { get; set; }
            public string Text { get; set; }
            public Color Color { get; set; }
            public int LifeTime { get; set; }
            public bool IsText { get; set; }
            public float Angle { get; set; }
            public int Size { get; set; }
        }

        private void UpdateEffects()
        {
            for (int i = _effects.Count -1; i >=0; i--)
            {
                var fx = _effects[i]; fx.LifeTime--; if (fx.IsText) fx.Y -=1.0f; if (fx.LifeTime <=0) _effects.RemoveAt(i);
            }
        }

        private float Distance(float x1, float y1, float x2, float y2) => (float)Math.Sqrt(Math.Pow(x2 - x1,2) + Math.Pow(y2 - y1,2));
        protected override void OnResize(EventArgs e)
        {
            base.OnResize(e);

            // Eğer kasaba modundaysak, pencere boyutu değişince NPC'leri tekrar ortala
            if (_isTownMode)
            {
                UpdateTownLayout();
            }
        }
        // UcArena sınıfı içine bu yardımcı metodu ekle:
        private void ClampEntityPosition(BattleEntity entity)
        {
            if (entity == null) return;

            // Genişlik ve Yükseklik sınırlarını al
            var (w, h) = GetArenaSize();

            // X Sınırı (0 ile Genişlik - Entity Genişliği arası)
            if (entity.X < 0) entity.X = 0;
            if (entity.X > w - entity.Width) entity.X = w - entity.Width;

            // Y Sınırı (0 ile Yükseklik - Entity Yüksekliği arası)
            if (entity.Y < 0) entity.Y = 0;
            if (entity.Y > h - entity.Height) entity.Y = h - entity.Height;
        }
        public class Projectile
        {
            public float X { get; set; }
            public float Y { get; set; }
            public float DX { get; set; }
            public float DY { get; set; }
            public int Damage { get; set; }
            public int Size { get; set; } = 8;
            public bool IsEnemy { get; set; } = false; // YENİ: Kim attı?

            public Rectangle Bounds => new Rectangle((int)X, (int)Y, Size, Size);

            public Projectile(float x, float y, float targetX, float targetY, int damage, bool isEnemy)
            {
                X = x; Y = y;
                Damage = damage;
                IsEnemy = isEnemy; // YENİ

                float speed = isEnemy ? 6.0f : 10.0f; // Düşman mermisi daha yavaş olsun ki kaçabilelim
                float dist = (float)Math.Sqrt(Math.Pow(targetX - x, 2) + Math.Pow(targetY - y, 2));

                DX = ((targetX - x) / dist) * speed;
                DY = ((targetY - y) / dist) * speed;
            }

            public void Move() { X += DX; Y += DY; }
        }
        private void DrawEnemy(Graphics g, BattleEntity en)
        {
            if (en.CurrentHP <= 0) return;

            // 1. Gövde Çizimi
            // İleride buraya "if (en.IsRanged) ..." diyerek farklı renk/resim koyabiliriz.
            Brush bodyBrush = en.IsRanged ? Brushes.Purple : Brushes.Crimson;
            g.FillRectangle(bodyBrush, en.X, en.Y, en.Width, en.Height);

            // 2. Can Barı Çizimi
            float hpPct = (float)en.CurrentHP / en.MaxHP;

            // Arkaplan (Koyu Kırmızı)
            g.FillRectangle(Brushes.DarkRed, en.X, en.Y - 10, en.Width, 5);
            // Doluluk (Açık Kırmızı/Turuncu)
            g.FillRectangle(Brushes.OrangeRed, en.X, en.Y - 10, en.Width * hpPct, 5);
            g.FillRectangle(bodyBrush, en.X, en.Y, en.Width, en.Height);////////

            // 3. İsim Etiketi (Tam Ortaya)
            if (!string.IsNullOrEmpty(en.Name))
            {
                using (Font font = new Font("Segoe UI", 7, FontStyle.Regular))
                using (Brush textBrush = new SolidBrush(Color.White))
                using (StringFormat sf = new StringFormat { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center })
                {
                    RectangleF rect = new RectangleF(en.X, en.Y, en.Width, en.Height);
                    g.DrawString(en.Name, font, textBrush, rect, sf);
                }
            }
        }
    }
}