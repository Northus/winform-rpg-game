using rpg_deneme.Business;
using rpg_deneme.Core; // Enums için
using rpg_deneme.Models;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Windows.Forms;
using Timer = System.Windows.Forms.Timer;

namespace rpg_deneme.UI.Controls
{
    public partial class UcArena : UserControl
    {
        private ArenaPanel _arena;
        private Timer _gameLoop;
        private Random _rnd = new Random();

        // --- HOTBAR SİSTEMİ ---
        private class HotbarSlot
        {
            public int Index { get; set; }
            public long? InstanceID { get; set; }
            public ItemInstance Item { get; set; }
        }
        private List<HotbarSlot> _hotbar = new List<HotbarSlot>();
        private ToolTip _hotbarTooltip = new ToolTip();

        // --- VARLIKLAR (ENTITIES) ---
        private BattleEntity _player;
        private List<BattleEntity> _enemies = new List<BattleEntity>(); // ARTIK SADECE LİSTE VAR
        private List<Projectile> _projectiles = new List<Projectile>();
        private List<VisualEffect> _effects = new List<VisualEffect>();

        // --- MANAGERS & MODELS ---
        private CharacterModel _hero;
        private InventoryManager _invManager = new InventoryManager();

        // --- BUTTONS & EVENTS ---
        private Button _btnMap;
        public event EventHandler OnMapRequested;
        public event EventHandler<bool> OnBattleEnded;
        public event EventHandler OnStatsUpdated;

        // --- TOWN & NPC ---
        private bool _isTownMode = false;
        private List<NpcEntity> _npcs = new List<NpcEntity>();
        public event EventHandler<NpcEntity> OnNpcInteraction;

        // --- KONTROL DEĞİŞKENLERİ ---
        private bool _w, _a, _s, _d;
        private Point _mousePos = Point.Empty;
        private int _attackDelayMs = 1000;
        private DateTime _lastAttackTime = DateTime.MinValue;
        private int _manaCostPerHit = 0;
        private bool _isBattleEnding = false;
        private int _enemyAttackCooldown = 0;

        public UcArena()
        {
            this.DoubleBuffered = true;
            this.BackColor = Color.Black;
            SetupArena();
        }

        private void SetupArena()
        {
            _arena = new ArenaPanel();
            _arena.Dock = DockStyle.Fill;
            _arena.BackColor = Color.FromArgb(45, 45, 48);
            _arena.Paint += Arena_Paint;
            _arena.MouseDown += Arena_MouseDown;
            _arena.MouseMove += (s, e) => { _mousePos = e.Location; HandleHotbarHover(e.Location); };

            _arena.AllowDrop = true;
            _arena.DragEnter += Arena_DragEnter;
            _arena.DragDrop += Arena_DragDrop;

            this.Controls.Add(_arena);
            this.Click += (s, e) => this.Focus();

            for (int i = 0; i < 5; i++) _hotbar.Add(new HotbarSlot { Index = i });
        }

        // --- BAŞLATMA METOTLARI ---

        // 1. Tekil Savaş (Eski sistem uyumu)
        public void StartBattle(CharacterModel hero, BattleEntity enemyTemplate)
        {
            PrepareBattleCommon(hero);

            var singleEnemy = new BattleEntity
            {
                X = this.Width - 100,
                Y = this.Height / 2 - 20,
                Width = enemyTemplate.Width,
                Height = enemyTemplate.Height,
                Speed = enemyTemplate.Speed,
                MaxHP = enemyTemplate.MaxHP,
                CurrentHP = enemyTemplate.MaxHP,
                Damage = enemyTemplate.Damage,
                Name = enemyTemplate.Name,
                IsRanged = enemyTemplate.IsRanged,
                AttackRange = enemyTemplate.AttackRange
            };

            // Ensure no overlap with player
            if (_player != null)
            {
                Rectangle playerRect = new Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height);
                Rectangle enemyRect = new Rectangle((int)singleEnemy.X, (int)singleEnemy.Y, singleEnemy.Width, singleEnemy.Height);
                int tries = 0;
                Random rnd = new Random();
                while (enemyRect.IntersectsWith(playerRect) && tries < 20)
                {
                    singleEnemy.X = this.Width - 100 - rnd.Next(0, 200);
                    singleEnemy.Y = 100 + rnd.Next(0, Math.Max(100, this.Height - 200));
                    enemyRect = new Rectangle((int)singleEnemy.X, (int)singleEnemy.Y, singleEnemy.Width, singleEnemy.Height);
                    tries++;
                }
            }

            _enemies.Add(singleEnemy);
            StartGameLoop();
        }

        // 2. Çoklu Savaş (Survival ve Yeni Zone Sistemi)
        public void StartSurvivalBattle(CharacterModel hero, List<EnemyModel> enemyTemplates)
        {
            PrepareBattleCommon(hero);

            var (w, h) = GetArenaSize();
            Random rnd = new Random();

            foreach (var tmpl in enemyTemplates)
            {
                // Try to find a spawn position that doesn't overlap player or other enemies
                int ex = w - 100 - rnd.Next(0, 200);
                int ey = 100 + rnd.Next(0, Math.Max(100, h - 200));

                bool isRangedUnit = tmpl.IsRanged || tmpl.Type == Enums.EnemyType.Ranged;
                int attackRange = tmpl.AttackRange > 0 ? tmpl.AttackRange : (isRangedUnit ? 250 : 50);

                var newEnemy = new BattleEntity
                {
                    X = ex,
                    Y = ey,
                    Width = tmpl.Width,
                    Height = tmpl.Height,
                    Speed = tmpl.Speed,
                    MaxHP = tmpl.MaxHP,
                    CurrentHP = tmpl.MaxHP,
                    Damage = tmpl.Damage,
                    Name = tmpl.Name,
                    IsRanged = isRangedUnit,
                    AttackRange = attackRange
                };

                // Spawn placement retry to avoid overlapping with player or existing enemies
                if (_player != null)
                {
                    Rectangle playerRect = new Rectangle((int)_player.X, (int)_player.Y, _player.Width, _player.Height);
                    Rectangle eRect = new Rectangle((int)newEnemy.X, (int)newEnemy.Y, newEnemy.Width, newEnemy.Height);
                    int tries = 0;
                    while ((eRect.IntersectsWith(playerRect) || _enemies.Any(en => en.Bounds.IntersectsWith(eRect))) && tries < 30)
                    {
                        ex = w - 100 - rnd.Next(0, 300);
                        ey = 80 + rnd.Next(0, Math.Max(100, h - 160));
                        newEnemy.X = ex;
                        newEnemy.Y = ey;
                        eRect = new Rectangle((int)newEnemy.X, (int)newEnemy.Y, newEnemy.Width, newEnemy.Height);
                        tries++;
                    }
                }

                _enemies.Add(newEnemy);
            }

            StartGameLoop();
        }

        // 3. Şehir Modu
        public void StartTown(CharacterModel hero)
        {
            _isBattleEnding = false;
            _hero = hero;
            LoadHotbarFromSession();
            _isTownMode = true;
            _projectiles.Clear();
            _enemies.Clear();
            _w = _a = _s = _d = false;

            InitTownEntities();
            UpdateTownLayout();

            var (w, h) = GetArenaSize();
            int maxHp = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);
            _player = new BattleEntity { X = w / 2 - 16, Y = h / 2 - 16, Width = 32, Height = 32, Speed = 5.0f, MaxHP = maxHp, CurrentHP = _hero.HP, Damage = 0, Defense = 0 };

            StartGameLoop();
        }

        private void PrepareBattleCommon(CharacterModel hero)
        {
            _hero = hero;
            LoadHotbarFromSession();
            _projectiles.Clear();
            _enemies.Clear();
            _w = _a = _s = _d = false;
            _isBattleEnding = false;
            _isTownMode = false;

            // ÖNEMLİ: MaxHP'yi hesapla - ekipman değiştiğinde değişebilir
            int maxHp = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);
            
            // CurrentHP'yi _hero.HP'den al ve MaxHP'yi aşmamasını sağla
            int currentHP = _hero.HP;
            if (currentHP > maxHp) currentHP = maxHp;
            if (currentHP <0) currentHP =0;
            
            // Start player in the horizontal and vertical center of the arena for battles
            var (arenaW, arenaH) = GetArenaSize();
            int startX = Math.Max(0, arenaW /2 -16);
            int startY = Math.Max(0, arenaH /2 -16);
            
            _player = new BattleEntity { X = startX, Y = startY, Width =32, Height =32, Speed =5.0f, MaxHP = maxHp, CurrentHP = currentHP, Damage =0, Defense =0 };

            // _hero.HP'yi de güncelle (senkronizasyon için)
            _hero.HP = currentHP;

            // Damage ve Defense RecalculatePlayerStats ile atanacak
            RecalculatePlayerStats();

            // Son kontrol: CurrentHP MaxHP'yi aşmamalı
            if (_player.CurrentHP > _player.MaxHP)
            {
                _player.CurrentHP = _player.MaxHP;
                _hero.HP = _player.MaxHP;
            }
        }

        public void RecalculatePlayerStats()
        {
            if (_hero == null || _player == null) return;
            var inventory = _invManager.GetInventory(_hero.CharacterID);
            var equippedWeapon = inventory.FirstOrDefault(x => x.Location == Enums.ItemLocation.Equipment && x.ItemType == Enums.ItemType.Weapon);
            var equippedItems = inventory.Where(x => x.Location == Enums.ItemLocation.Equipment).ToList();

            int calculatedDamage = (_hero.Class == (byte)Enums.CharacterClass.Mage)
                ? StatManager.CalculateMagicalDamage(_hero, equippedWeapon)
                : StatManager.CalculatePhysicalDamage(_hero, equippedWeapon);

            int calculatedDefense = StatManager.CalculateTotalDefense(_hero, equippedItems);
            float attackSpeed = StatManager.CalculateAttackSpeed(_hero, equippedWeapon);

            _attackDelayMs = (int)(1000f / attackSpeed);
            _manaCostPerHit = StatManager.CalculateAttackManaCost(_hero);

            _player.Damage = calculatedDamage;
            _player.Defense = calculatedDefense;
            
            // ÖNEMLİ: MaxHP'yi güncelle - ekipman değiştiğinde VIT değişebilir
            int newMaxHP = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);
            int oldMaxHP = _player.MaxHP;
            _player.MaxHP = newMaxHP;
            
            // MaxHP değiştiyse, CurrentHP'yi orantılı olarak ayarla veya clamp et
            if (oldMaxHP > 0 && newMaxHP != oldMaxHP)
            {
                // Eğer MaxHP azaldıysa, CurrentHP'yi yeni MaxHP'ye clamp et
                if (_player.CurrentHP > newMaxHP)
                {
                    _player.CurrentHP = newMaxHP;
                    _hero.HP = newMaxHP; // _hero.HP'yi de güncelle
                }
                // Eğer MaxHP arttıysa, mevcut yüzdeyi koru (opsiyonel - şimdilik sadece clamp yapıyoruz)
            }
            
            // CurrentHP'nin MaxHP'yi aşmadığından emin ol
            if (_player.CurrentHP > _player.MaxHP)
            {
                _player.CurrentHP = _player.MaxHP;
                _hero.HP = _player.MaxHP;
            }
        }

        private void StartGameLoop()
        {
            if (_gameLoop == null)
            {
                _gameLoop = new Timer { Interval = 16 };
                _gameLoop.Tick += GameTick;
            }
            _gameLoop.Start();
            this.Focus();
        }

        // --- OYUN DÖNGÜSÜ (TICK) ---
        private void GameTick(object sender, EventArgs e)
        {
            if (_player == null) return;

            if (_isBattleEnding)
            {
                UpdateEffects();
                _arena.Invalidate();
                return;
            }

            if (_hero != null)
            {
                // ÖNEMLİ: Can senkronizasyonu - _hero.HP ana kaynak
                // Önce MaxHP'yi güncelle (ekipman değiştiğinde değişebilir)
                int newMaxHP = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);
                if (_player.MaxHP != newMaxHP)
                {
                    _player.MaxHP = newMaxHP;
                    // MaxHP değiştiyse, CurrentHP'yi clamp et
                    if (_player.CurrentHP > newMaxHP)
                    {
                        _player.CurrentHP = newMaxHP;
                        _hero.HP = newMaxHP;
                    }
                }
                
                // CurrentHP'yi _hero.HP'den al (ana kaynak)
                _player.CurrentHP = _hero.HP;
                
                // Güvenlik kontrolü: CurrentHP MaxHP'yi aşmamalı
                if (_player.CurrentHP > _player.MaxHP)
                {
                    _player.CurrentHP = _player.MaxHP;
                    _hero.HP = _player.MaxHP;
                }
            }

            UpdatePlayer();
            UpdateProjectiles();
            UpdateEffects();
            UpdateHotbarState();

            if (!_isTownMode)
            {
                UpdateEnemies();
            }

            _arena.Invalidate();
        }

        // --- GÜNCELLENMİŞ DÜŞMAN FİZİĞİ ---
        private void UpdateEnemies()
        {
            if (_enemyAttackCooldown > 0) _enemyAttackCooldown--;

            int aliveCount = 0;

            for (int i = 0; i < _enemies.Count; i++)
            {
                var enemy = _enemies[i];
                if (enemy.CurrentHP <= 0) continue;
                aliveCount++;

                // 1. OYUNCUYA MESAFE (Sıfıra Bölme Koruması)
                float distToPlayer = Distance(enemy.Center.X, enemy.Center.Y, _player.Center.X, _player.Center.Y);
                if (distToPlayer < 0.001f) distToPlayer = 0.001f; // FIX: NaN oluşumunu engelle

                float dx = _player.X - enemy.X;
                float dy = _player.Y - enemy.Y;
                float dirX = dx / distToPlayer;
                float dirY = dy / distToPlayer;

                // 2. SEPARATION (Düşmanlar birbirini itsin) - separation radius scales with entity size to avoid large entities overlapping
                float sepX =0, sepY =0;
                int neighbors =0;
                float separationRadius = Math.Max(48f, Math.Max(enemy.Width, enemy.Height) *0.8f);
                foreach (var other in _enemies)
                {
                    if (other == enemy || other.CurrentHP <=0) continue;
                    float distToOther = Distance(enemy.Center.X, enemy.Center.Y, other.Center.X, other.Center.Y);
                    if (distToOther < separationRadius)
                    {
                        if (distToOther <0.001f) distToOther =0.001f; // FIX
                        // stronger push when overlap ratio is higher
                        float overlapFactor = (separationRadius - distToOther) / separationRadius;
                        sepX += (enemy.X - other.X) / distToOther * overlapFactor;
                        sepY += (enemy.Y - other.Y) / distToOther * overlapFactor;
                        neighbors++;
                    }
                }
                if (neighbors >0)
                {
                    sepX /= neighbors; sepY /= neighbors;
                }

                // 3. HAREKET KARARI
                float desiredRange = enemy.AttackRange > 0 ? enemy.AttackRange : (enemy.IsRanged ? 250f : 40f);

                // base movement direction towards player
                float moveX = dirX; float moveY = dirY;

                if (enemy.IsRanged)
                {
                    // Per-enemy decision cooldown: pick behavior less often to avoid jitter
                    if (enemy.DecisionCooldown >0) enemy.DecisionCooldown--;
                    if (enemy.DecisionCooldown <=0)
                    {
                        if (distToPlayer > desiredRange) enemy.AIState =2; // approach
                        else if (distToPlayer <= desiredRange *0.5f)
                        {
                            // When very close, prefer strafing/holding (70%) over full backoff (30%) so player can engage
                            enemy.AIState = (_rnd.NextDouble() <0.7) ?1 :0;
                        }
                        else enemy.AIState =1; // hold/strafe

                        // pick a stable strafe sign so strafing direction doesn't flip each frame
                        enemy.StrafeSign = _rnd.Next(0,2) ==0 ? -1 :1;
                        enemy.DecisionCooldown = _rnd.Next(18,48); // ~0.3-0.8 seconds
                    }

                    // Behavior by AIState:
                    //0 = backoff (kite),1 = strafe/hold,2 = approach
                    switch (enemy.AIState)
                    {
                        case 0: // backoff
                            moveX = -dirX *0.9f + sepX *1.2f;
                            moveY = -dirY *0.9f + sepY *1.2f;
                            break;
                        case 1: // strafe / hold
                            // perpendicular vector for strafing, use stable sign chosen at decision time
                            float perpX = -dirY * enemy.StrafeSign;
                            float perpY = dirX * enemy.StrafeSign;
                            moveX = perpX *0.6f + sepX *0.8f;
                            moveY = perpY *0.6f + sepY *0.8f;
                            // if slightly out of range sometimes step closer
                            if (distToPlayer > desiredRange *0.9f && _rnd.NextDouble() <0.25) { moveX = dirX *0.6f + sepX *0.4f; moveY = dirY *0.6f + sepY *0.4f; }
                            break;
                        default: //2 approach
                            moveX = dirX + sepX *0.6f;
                            moveY = dirY + sepY *0.6f;
                            break;
                    }
                }
                else
                {
                    // Melee: approach until within melee range, avoid overlap
                    if (distToPlayer <= desiredRange)
                    {
                        moveX = sepX *1.0f; moveY = sepY *1.0f; // slight reposition to avoid stacking
                    }
                    else
                    {
                        moveX = dirX + sepX *0.9f; moveY = dirY + sepY *0.9f;
                    }
                }

                // normalize move vector
                float mag = (float)Math.Sqrt(moveX * moveX + moveY * moveY);
                if (mag < 0.001f) { moveX = 0; moveY = 0; }
                else { moveX /= mag; moveY /= mag; }

                // smooth velocity to avoid instant reversals / jitter
                enemy.VX = Lerp(enemy.VX, moveX * enemy.Speed,0.18f);
                enemy.VY = Lerp(enemy.VY, moveY * enemy.Speed,0.18f);

                // ÖNEMLİ: Minimum mesafe kontrolü - titreşimi önlemek için
                // Oyuncuya minimum mesafe = entity boyutlarının toplamı + buffer
                float minDistance = (enemy.Width + _player.Width) / 2.0f + 2.0f; // 2 pixel buffer
                
                // Melee düşmanlar için minimum mesafe = saldırı mesafesi
                if (!enemy.IsRanged)
                {
                    minDistance = Math.Max(minDistance, desiredRange);
                }

                // Hareket öncesi kontrol: Eğer hareket sonrası çok yakın olacaksa, hareketi sınırlandır
                float proposedX = enemy.X + enemy.VX;
                float proposedY = enemy.Y + enemy.VY;
                float proposedDist = Distance(proposedX + enemy.Width / 2.0f, proposedY + enemy.Height / 2.0f, 
                                               _player.Center.X, _player.Center.Y);

                // Eğer hareket sonrası minimum mesafeden daha yakın olacaksa, hareketi engelle veya sınırlandır
                if (proposedDist < minDistance && distToPlayer <= minDistance)
                {
                    // Zaten çok yakınsa, oyuncudan uzaklaş
                    enemy.VX = -dirX * enemy.Speed * 0.3f;
                    enemy.VY = -dirY * enemy.Speed * 0.3f;
                }
                else if (proposedDist < minDistance)
                {
                    // Yaklaşıyor ama henüz çok yakın değil, hareketi sınırlandır
                    float allowedDist = distToPlayer - minDistance;
                    if (allowedDist > 0)
                    {
                        float scale = Math.Min(1.0f, allowedDist / (float)Math.Sqrt(enemy.VX * enemy.VX + enemy.VY * enemy.VY));
                        enemy.VX *= scale;
                        enemy.VY *= scale;
                    }
                    else
                    {
                        // Zaten çok yakın, uzaklaş
                        enemy.VX = -dirX * enemy.Speed * 0.3f;
                        enemy.VY = -dirY * enemy.Speed * 0.3f;
                    }
                }

                enemy.X += enemy.VX;
                enemy.Y += enemy.VY;

                // Çarpışma kontrolü ve düzeltme (son çare olarak)
                if (_player != null && enemy.Bounds.IntersectsWith(_player.Bounds))
                {
                    // Çakışma varsa, düşmanı oyuncudan uzaklaştır
                    float overlapX = (enemy.X + enemy.Width / 2.0f) - (_player.X + _player.Width / 2.0f);
                    float overlapY = (enemy.Y + enemy.Height / 2.0f) - (_player.Y + _player.Height / 2.0f);
                    float overlapDist = (float)Math.Sqrt(overlapX * overlapX + overlapY * overlapY);
                    
                    if (overlapDist < 0.001f) 
                    { 
                        overlapX = 1.0f; 
                        overlapY = 0.0f; 
                        overlapDist = 1.0f; 
                    }
                    
                    // Minimum mesafeye kadar it
                    float pushDist = minDistance - overlapDist + 2.0f;
                    if (pushDist > 0)
                    {
                        enemy.X += (overlapX / overlapDist) * pushDist;
                        enemy.Y += (overlapY / overlapDist) * pushDist;
                    }
                }

                //4. SALDIRI
                if (enemy.IsRanged && distToPlayer <= desiredRange +50)
                {
                    // firing chance increased when holding/approaching, reduced when backing off
                    double fireChance =0.008; // base
                    if (enemy.AIState ==1) fireChance =0.02;
                    else if (enemy.AIState ==2) fireChance =0.025;
                    if (_rnd.NextDouble() < fireChance)
                    {
                        var proj = new Projectile(enemy.Center.X, enemy.Center.Y, _player.Center.X, _player.Center.Y, enemy.Damage, true);
                        _projectiles.Add(proj);
                    }
                }
                else if (!enemy.IsRanged && distToPlayer <= desiredRange)
                {
                    if (_enemyAttackCooldown <=0)
                    {
                        ApplyDamageToPlayer(enemy.Damage);
                        _enemyAttackCooldown =60; // Oyuncu bir süre hasar almaz

                        // Geri itme
                        // push player away from enemy (use dir vector which points from enemy to player)
                        _player.X += dirX *30f;
                        _player.Y += dirY *30f;
                        ClampEntityPosition(_player);
                    }
                }

                ClampEntityPosition(enemy);
            }

            if (aliveCount ==0 && !_isBattleEnding) StartBattleEndSequence(true);
        }

        private static float Lerp(float a, float b, float t) => a + (b - a) * t;

        // --- PLAYER UPDATE (Collision Fix) ---
        private void UpdatePlayer()
        {
            float proposedX = _player.X;
            float proposedY = _player.Y;

            if (_w) proposedY -= _player.Speed;
            if (_s) proposedY += _player.Speed;
            if (_a) proposedX -= _player.Speed;
            if (_d) proposedX += _player.Speed;

            var proposedRect = new Rectangle((int)proposedX, (int)proposedY, _player.Width, _player.Height);
            bool collides = false;

            if (_isTownMode)
            {
                foreach (var npc in _npcs)
                {
                    var npcRect = new Rectangle((int)npc.X, (int)npc.Y, npc.Width, npc.Height);
                    if (proposedRect.IntersectsWith(npcRect)) { collides = true; break; }
                }
            }
            else
            {
                // Minimum mesafe kontrolü - titreşimi önlemek için
                float minDistance = 0.0f; // Oyuncu için minimum mesafe (saldırı için yaklaşabilir ama çakışmamalı)
                
                foreach (var en in _enemies)
                {
                    if (en.CurrentHP > 0)
                    {
                        // Minimum mesafe = entity boyutlarının toplamı / 2 + küçük buffer
                        minDistance = (_player.Width + en.Width) / 2.0f + 1.0f;
                        
                        // Önerilen pozisyonun merkez noktası
                        float proposedCenterX = proposedX + _player.Width / 2.0f;
                        float proposedCenterY = proposedY + _player.Height / 2.0f;
                        
                        // Düşmanın merkez noktası
                        float enemyCenterX = en.X + en.Width / 2.0f;
                        float enemyCenterY = en.Y + en.Height / 2.0f;
                        
                        // Mesafe kontrolü
                        float distToEnemy = Distance(proposedCenterX, proposedCenterY, enemyCenterX, enemyCenterY);
                        
                        // Eğer önerilen pozisyon minimum mesafeden daha yakınsa, hareketi engelle
                        if (distToEnemy < minDistance)
                        {
                            collides = true;
                            break;
                        }
                        
                        // Ayrıca çakışma kontrolü (güvenlik için)
                        var enemyRect = new Rectangle((int)en.X, (int)en.Y, en.Width, en.Height);
                        if (proposedRect.IntersectsWith(enemyRect)) 
                        { 
                            collides = true; 
                            break; 
                        }
                    }
                }
            }

            if (!collides)
            {
                _player.X = proposedX;
                _player.Y = proposedY;
                ClampEntityPosition(_player);
            }
        }

        // --- DRAW ENEMY (OVERFLOW FIX) ---
        private void DrawEnemy(Graphics g, BattleEntity en)
        {
            if (en.CurrentHP <= 0) return;

            // FIX: NaN ve Infinity Koruması (Overflow Hatası Sebebi)
            if (float.IsNaN(en.X) || float.IsInfinity(en.X)) en.X = 0;
            if (float.IsNaN(en.Y) || float.IsInfinity(en.Y)) en.Y = 0;

            // FIX: Aşırı büyük koordinat koruması
            if (en.X < -10000 || en.X > 10000 || en.Y < -10000 || en.Y > 10000) return;

            // 1. Gövde
            Brush bodyBrush = en.IsRanged ? Brushes.Purple : Brushes.Crimson;
            g.FillRectangle(bodyBrush, en.X, en.Y, en.Width, en.Height);

            // 2. Can Barı
            float hpPct = (float)en.CurrentHP / en.MaxHP;
            g.FillRectangle(Brushes.DarkRed, en.X, en.Y - 10, en.Width, 5);
            g.FillRectangle(Brushes.OrangeRed, en.X, en.Y - 10, en.Width * hpPct, 5);

            // 3. İsim
            if (!string.IsNullOrEmpty(en.Name))
            {
                using (Font font = new Font("Segoe UI", 7, FontStyle.Regular))
                using (Brush textBrush = new SolidBrush(Color.White))
                using (StringFormat sf = new StringFormat { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center })
                {
                    // RectangleF kullanmak DrawString hassasiyeti için daha iyidir
                    RectangleF rect = new RectangleF(en.X, en.Y, en.Width, en.Height);
                    g.DrawString(en.Name, font, textBrush, rect, sf);
                }
            }
        }

        // --- DİĞER STANDART METOTLAR ---
        private void UpdateProjectiles()
        {
            for (int i = _projectiles.Count - 1; i >= 0; i--)
            {
                var proj = _projectiles[i];
                proj.Move();

                if (proj.X < 0 || proj.X > _arena.Width || proj.Y < 0 || proj.Y > _arena.Height) { _projectiles.RemoveAt(i); continue; }

                bool hit = false;
                if (proj.IsEnemy) // Düşman mermisi oyuncuya
                {
                    if (_player.Bounds.IntersectsWith(proj.Bounds)) { ApplyDamageToPlayer(proj.Damage); hit = true; }
                }
                else // Oyuncu mermisi düşmanlara
                {
                    foreach (var en in _enemies)
                    {
                        if (en.CurrentHP > 0 && proj.Bounds.IntersectsWith(en.Bounds))
                        {
                            ApplyDamageToEnemy(en, proj.Damage);
                            hit = true;
                            break;
                        }
                    }
                }
                if (hit) _projectiles.RemoveAt(i);
            }
        }

        private void Arena_MouseDown(object sender, MouseEventArgs e)
        {
            if (_hero == null || _player == null || _isBattleEnding) return;

            // Hotbar Check
            for (int i = 0; i < _hotbar.Count; i++)
            {
                if (GetHotbarSlotRect(i).Contains(e.Location))
                {
                    if (e.Button == MouseButtons.Left) { _hotbar[i].InstanceID = null; _hotbar[i].Item = null; SaveHotbarToSession(); }
                    else if (e.Button == MouseButtons.Right) { UseHotbarSlot(i); }
                    return;
                }
            }

            // Saldırı
            if (e.Button == MouseButtons.Left)
            {
                if ((DateTime.Now - _lastAttackTime).TotalMilliseconds < _attackDelayMs) return;
                // In town mode we don't consume mana or block attacks due to low mana.
                if (!_isTownMode)
                {
                    if (_hero.Mana < _manaCostPerHit) return;
                    _hero.Mana -= _manaCostPerHit;
                }
                _lastAttackTime = DateTime.Now;
                OnStatsUpdated?.Invoke(this, EventArgs.Empty);

                if (_hero.Class == (byte)Enums.CharacterClass.Mage)
                {
                    _projectiles.Add(new Projectile(_player.Center.X, _player.Center.Y, e.X, e.Y, _player.Damage, false));
                }
                else
                {
                    // MELEE ATTACK
                    _effects.Add(new VisualEffect { X = e.X - 10, Y = e.Y - 10, Color = Color.WhiteSmoke, Size = 20, LifeTime = 10 });
                    if (!_isTownMode)
                    {
                        BattleEntity target = null;
                        // Tıklanan
                        foreach (var en in _enemies) if (en.CurrentHP > 0 && en.Bounds.Contains(e.Location)) { target = en; break; }
                        // Yoksa en yakın
                        if (target == null)
                        {
                            foreach (var en in _enemies)
                            {
                                if (en.CurrentHP <= 0) continue;
                                if (Distance(_player.Center.X, _player.Center.Y, en.Center.X, en.Center.Y) < 80f) { target = en; break; }
                            }
                        }
                        if (target != null && Distance(_player.Center.X, _player.Center.Y, target.Center.X, target.Center.Y) <= 80f)
                        {
                            ApplyDamageToEnemy(target, _player.Damage);
                        }
                    }
                }
            }
            // NPC
            if (_isTownMode && e.Button == MouseButtons.Right)
            {
                foreach (var npc in _npcs)
                {
                    if (Distance(e.X, e.Y, npc.Center.X, npc.Center.Y) < 60 && Distance(_player.Center.X, _player.Center.Y, npc.Center.X, npc.Center.Y) < 150)
                    {
                        OnNpcInteraction?.Invoke(this, npc);
                        return;
                    }
                }
            }
        }

        // --- HELPER METHODS ---
        private void ApplyDamageToPlayer(int dmg)
        {
            if (_isBattleEnding) return;
            int reduced = Math.Max(1, dmg - _player.Defense);
            _player.CurrentHP -= reduced;
            
            // CurrentHP'yi 0'ın altına düşürme
            if (_player.CurrentHP < 0) _player.CurrentHP = 0;
            
            // _hero.HP'yi güncelle (ana kaynak)
            _hero.HP = _player.CurrentHP;
            
            // MaxHP kontrolü - eğer MaxHP değiştiyse güncelle
            int currentMaxHP = StatManager.CalculateMaxHP(_hero.VIT, _hero.Level);
            if (_player.MaxHP != currentMaxHP)
            {
                _player.MaxHP = currentMaxHP;
                // CurrentHP MaxHP'yi aşmamalı
                if (_player.CurrentHP > _player.MaxHP)
                {
                    _player.CurrentHP = _player.MaxHP;
                    _hero.HP = _player.MaxHP;
                }
            }
            
            OnStatsUpdated?.Invoke(this, EventArgs.Empty);
            if (_player.CurrentHP <= 0) StartBattleEndSequence(false);
        }

        private void ApplyDamageToEnemy(BattleEntity target, int dmg)
        {
            target.CurrentHP -= dmg;
            _effects.Add(new VisualEffect { X = target.X + 10, Y = target.Y, Text = $"-{dmg}", Color = Color.Yellow, IsText = true, LifeTime = 30 });
            if (target.CurrentHP < 0) target.CurrentHP = 0;
        }

        private async void StartBattleEndSequence(bool victory)
        {
            _isBattleEnding = true;
            await System.Threading.Tasks.Task.Delay(1000);
            _gameLoop.Stop();
            _isBattleEnding = false;
            OnBattleEnded?.Invoke(this, victory);
        }

        private void ClampEntityPosition(BattleEntity entity)
        {
            if (entity == null) return;
            var (w, h) = GetArenaSize();
            if (entity.X < 0) entity.X = 0;
            if (entity.X > w - entity.Width) entity.X = w - entity.Width;
            if (entity.Y < 0) entity.Y = 0;
            if (entity.Y > h - entity.Height) entity.Y = h - entity.Height;
        }

        private float Distance(float x1, float y1, float x2, float y2) => (float)Math.Sqrt(Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2));

        // --- HOTBAR, RESIZE, PAINT, CLASSES (Kalan kısımlar standart) ---
        private void Arena_Paint(object sender, PaintEventArgs e)
        {
            if (_player == null) return;
            Graphics g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

            // Player
            Brush playerColor = _hero != null && _hero.Class == (byte)Enums.CharacterClass.Mage ? Brushes.CornflowerBlue : Brushes.DarkOrange;
            g.FillRectangle(playerColor, _player.X, _player.Y, _player.Width, _player.Height);
            if (_player.MaxHP > 0)
            {
                float pct = (float)_player.CurrentHP / _player.MaxHP;
                g.FillRectangle(Brushes.Red, _player.X, _player.Y - 10, _player.Width, 5);
                g.FillRectangle(Brushes.Lime, _player.X, _player.Y - 10, _player.Width * pct, 5);
            }

            // Projectiles
            foreach (var proj in _projectiles) g.FillEllipse(proj.IsEnemy ? Brushes.Violet : Brushes.Cyan, proj.X, proj.Y, proj.Size, proj.Size);

            // NPC
            if (_isTownMode)
            {
                using (Font font = new Font("Segoe UI", 8, FontStyle.Bold))
                using (Brush textBrush = new SolidBrush(Color.White))
                {
                    foreach (var npc in _npcs)
                    {
                        using (Brush b = new SolidBrush(npc.Color)) g.FillRectangle(b, npc.X, npc.Y, npc.Width, npc.Height);
                        SizeF size = g.MeasureString(npc.Name, font);
                        g.DrawString(npc.Name, font, textBrush, npc.X + (npc.Width - size.Width) / 2, npc.Y - 15);
                    }
                }
            }
            // Enemies
            else
            {
                foreach (var en in _enemies) DrawEnemy(g, en);
            }

            // Effects
            foreach (var fx in _effects)
            {
                if (fx.IsText)
                {
                    using (Font f = new Font("Segoe UI", 12, FontStyle.Bold))
                    {
                        g.DrawString(fx.Text, f, Brushes.Black, fx.X + 1, fx.Y + 1);
                        using (Brush b = new SolidBrush(fx.Color)) g.DrawString(fx.Text, f, b, fx.X, fx.Y);
                    }
                }
                else
                {
                    using (Pen p = new Pen(fx.Color, 3))
                    {
                        g.DrawLine(p, fx.X, fx.Y, fx.X + fx.Size, fx.Y + fx.Size);
                        g.DrawLine(p, fx.X + fx.Size, fx.Y, fx.X, fx.Y + fx.Size);
                    }
                }
            }
            DrawHotbar(g);
        }
        // --- HOTBAR YÖNETİMİ ---
        private void LoadHotbarFromSession()
        {
            for (int i = 0; i < 5; i++)
            {
                var id = Core.SessionManager.HotbarSlots[i];
                if (id.HasValue && _hero != null)
                {
                    var inv = _invManager.GetInventory(_hero.CharacterID);
                    var item = inv.FirstOrDefault(x => x.InstanceID == id.Value);
                    _hotbar[i].InstanceID = item != null ? id : null;
                    _hotbar[i].Item = item;
                }
                else { _hotbar[i].InstanceID = null; _hotbar[i].Item = null; }
            }
        }
        private void SaveHotbarToSession() { for (int i = 0; i < 5; i++) Core.SessionManager.HotbarSlots[i] = _hotbar[i].InstanceID; }
        private void UpdateHotbarState() { LoadHotbarFromSession(); }
        public void HandleKeyDown(Keys key)
        {
            if (key == Keys.W) _w = true; if (key == Keys.S) _s = true; if (key == Keys.A) _a = true; if (key == Keys.D) _d = true;
            HandleHotbarKey(key);
        }
        public void HandleKeyUp(Keys key) { if (key == Keys.W) _w = false; if (key == Keys.S) _s = false; if (key == Keys.A) _a = false; if (key == Keys.D) _d = false; }
        public void HandleHotbarKey(Keys key)
        {
            int idx = -1;
            if (key >= Keys.D1 && key <= Keys.D5) idx = key - Keys.D1;
            else if (key >= Keys.NumPad1 && key <= Keys.NumPad5) idx = key - Keys.NumPad1;
            if (idx >= 0) UseHotbarSlot(idx);
        }
        private void UseHotbarSlot(int idx)
        {
            if (idx < 0 || idx >= _hotbar.Count || _hotbar[idx].Item == null) return;
            var item = _hotbar[idx].Item;
            if (item.RemainingCooldownSeconds > 0) return;

            var cm = new ConsumableManager();
            if (cm.UseItem(_hero, item).Success)
            {
                OnStatsUpdated?.Invoke(this, EventArgs.Empty);
                SaveHotbarToSession();
                if (this.ParentForm is FormMain m) m.RefreshStats();
            }
        }
        private void HandleHotbarHover(Point pt)
        {
            for (int i = 0; i < _hotbar.Count; i++)
            {
                if (GetHotbarSlotRect(i).Contains(pt) && _hotbar[i].Item != null)
                {
                    var slot = new UcItemSlot(0); // Dummy for tooltip text
                    _hotbarTooltip.Show(slot.GetTooltipText(_hotbar[i].Item), _arena, pt.X + 15, pt.Y);
                    return;
                }
            }
            _hotbarTooltip.Hide(_arena);
        }
        private void DrawHotbar(Graphics g)
        {
            for (int i = 0; i < _hotbar.Count; i++)
            {
                var rect = GetHotbarSlotRect(i);
                using (Brush b = new SolidBrush(Color.FromArgb(50, 50, 50))) g.FillRectangle(b, rect);
                using (Pen p = new Pen(Color.DimGray)) g.DrawRectangle(p, rect);

                var slot = _hotbar[i];
                if (slot.Item != null)
                {
                    var color = GetHotbarColor(slot.Item.Grade, slot.Item.ItemType);
                    using (Brush ib = new SolidBrush(color)) g.FillRectangle(ib, rect.X + 4, rect.Y + 4, rect.Width - 8, rect.Height - 8);

                    if (slot.Item.Count > 1)
                    {
                        using (Font f = new Font("Segoe UI", 9, FontStyle.Bold))
                        using (Brush fb = new SolidBrush(Color.White)) g.DrawString(slot.Item.Count.ToString(), f, fb, rect.Right - 20, rect.Bottom - 20);
                    }
                    if (slot.Item.RemainingCooldownSeconds > 0)
                    {
                        float frac = (float)slot.Item.RemainingCooldownSeconds / slot.Item.Cooldown;
                        using (Brush cb = new SolidBrush(Color.FromArgb(180, 0, 0, 0))) g.FillPie(cb, rect.X + 6, rect.Y + 6, rect.Width - 12, rect.Height - 12, -90, 360 * frac);
                    }
                }
                using (Font f = new Font("Segoe UI", 9)) g.DrawString((i + 1).ToString(), f, Brushes.Gray, rect.X + 2, rect.Y + 2);
            }
        }
        private Rectangle GetHotbarSlotRect(int index)
        {
            int slotSize = 40, gap = 8;
            int totalWidth = slotSize * 5 + gap * 4;
            int startX = (_arena.Width - totalWidth) / 2;
            int y = _arena.Height - slotSize - 10;
            return new Rectangle(startX + index * (slotSize + gap), y, slotSize, slotSize);
        }
        private Color GetHotbarColor(Enums.ItemGrade grade, Enums.ItemType type)
        {
            if (type == Enums.ItemType.Consumable) return Color.MediumSeaGreen;
            return grade switch { Enums.ItemGrade.Common => Color.WhiteSmoke, Enums.ItemGrade.Rare => Color.CornflowerBlue, Enums.ItemGrade.Epic => Color.MediumPurple, Enums.ItemGrade.Legendary => Color.Orange, _ => Color.Gray };
        }
        private (int, int) GetArenaSize() => (_arena?.ClientSize.Width ?? 1024, _arena?.ClientSize.Height ?? 720);

        private void Arena_DragEnter(object sender, DragEventArgs e) { if (e.Data.GetDataPresent(typeof(ItemInstance))) e.Effect = DragDropEffects.Move; }
        private void Arena_DragDrop(object sender, DragEventArgs e)
        {
            if (!e.Data.GetDataPresent(typeof(ItemInstance))) return;
            var item = (ItemInstance)e.Data.GetData(typeof(ItemInstance));
            var pt = _arena.PointToClient(new Point(e.X, e.Y));
            for (int i = 0; i < 5; i++) if (GetHotbarSlotRect(i).Contains(pt)) { _hotbar[i].InstanceID = item.InstanceID; _hotbar[i].Item = item; SaveHotbarToSession(); break; }
        }
        protected override void OnResize(EventArgs e) { base.OnResize(e); if (_isTownMode) UpdateTownLayout(); }

        // --- TOWN LAYOUT ---
        private void InitTownEntities()
        {
            _npcs = new List<NpcEntity> {
                new NpcEntity("MARKET", Enums.NpcType.Merchant, 0, 0),
                new NpcEntity("IŞINLAYICI", Enums.NpcType.Teleporter, 0, 0),
                new NpcEntity("DEPOCU", Enums.NpcType.StorageKeeper, 0, 0) { Color = Color.Brown },
                new NpcEntity("DEMİRCİ", Enums.NpcType.BlackSmith, 0, 0) { Color = Color.DarkSlateGray },
                new NpcEntity("ARENA GUARD", Enums.NpcType.ArenaMaster, 0, 0) { Color = Color.Red }
            };
        }
        private void UpdateTownLayout()
        {
            if (!_isTownMode) return;
            var (w, h) = GetArenaSize();
            int cy = h / 2 - 20;
            foreach (var npc in _npcs)
            {
                if (npc.Type == Enums.NpcType.Merchant) { npc.X = w / 4 - 40; npc.Y = cy; }
                else if (npc.Type == Enums.NpcType.Teleporter) { npc.X = w * 3 / 4 - 40; npc.Y = cy; }
                else if (npc.Name == "DEPOCU") { npc.X = w / 2 - 20; npc.Y = cy - 150; }
                else if (npc.Name == "DEMİRCİ") { npc.X = w / 2 - 20; npc.Y = cy + 150; }
                else if (npc.Name == "ARENA GUARD") { npc.X = w * 3 / 4 - 40; npc.Y = cy + 120; }
            }
            if (_btnMap != null) _btnMap.Location = new Point(w - 180, 20);
        }
        // --- SUB CLASSES ---
        public class VisualEffect { public float X, Y; public string Text; public Color Color; public int LifeTime; public bool IsText; public int Size; }
        public class Projectile
        {
            public float X, Y, DX, DY; public int Damage, Size = 8; public bool IsEnemy;
            public Rectangle Bounds => new Rectangle((int)X, (int)Y, Size, Size);
            public Projectile(float x, float y, float tx, float ty, int dmg, bool enemy)
            {
                X = x; Y = y; Damage = dmg; IsEnemy = enemy;
                float spd = enemy ? 6f : 10f;
                float dist = (float)Math.Sqrt(Math.Pow(tx - x, 2) + Math.Pow(ty - y, 2));
                DX = ((tx - x) / dist) * spd; DY = ((ty - y) / dist) * spd;
            }
            public void Move() { X += DX; Y += DY; }
        }
        private void UpdateEffects()
        {
            for (int i = _effects.Count - 1; i >= 0; i--)

            {
                var fx = _effects[i]; fx.LifeTime--; if (fx.IsText) fx.Y -= 1.0f; if (fx.LifeTime <= 0) _effects.RemoveAt(i);
            }
        }
    }
}